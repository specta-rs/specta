//! [Zod](https://zod.dev) schema exporter for TypeScript.
//!
//! # Usage
//!
//! Add `specta` and `specta-zod` to your project:
//!
//! ```bash
//! cargo add specta@2.0.0-rc.22 --features derive,export
//! cargo add specta-zod@0.0.1
//! cargo add specta-serde@0.0.9
//! ```
//!
//! Next copy the following into your `main.rs` file:
//!
//! ```rust
//! use specta::{Type, TypeCollection};
//! use specta_zod::Zod;
//!
//! #[derive(Type)]
//! pub struct MyType {
//!     pub field: MyOtherType,
//! }
//!
//! #[derive(Type)]
//! pub struct MyOtherType {
//!     pub other_field: String,
//! }
//!
//! fn main() {
//!     let mut types = TypeCollection::default()
//!         // We don't need to specify `MyOtherType` because it's referenced by `MyType`
//!         .register::<MyType>();
//!
//!     Zod::default()
//!         .export_to("./schemas.ts", &types)
//!         .unwrap();
//! }
//! ```
//!
//! Now your setup with Specta!
//!
//! If you get tired of listing all your types, checkout [`specta::export`].
//!
#![cfg_attr(docsrs, feature(doc_cfg))]
#![doc(
    html_logo_url = "https://github.com/specta-rs/specta/raw/main/.github/logo-128.png",
    html_favicon_url = "https://github.com/specta-rs/specta/raw/main/.github/logo-128.png"
)]

mod context;
mod error;
mod export_config;

use std::{borrow::Cow, collections::HashMap, path::Path};

use specta::{
    TypeCollection,
    datatype::{DataType, EnumRepr, Fields, NamedDataType, Primitive},
};

pub use context::*;
pub use error::{Error, NamedLocation};
pub use export_config::*;

/// Zod schema exporter.
#[derive(Debug, Clone)]
#[non_exhaustive]
pub struct Zod {
    pub header: Cow<'static, str>,
    pub framework_header: Cow<'static, str>,
    pub bigint: BigIntExportBehavior,
}

impl Default for Zod {
    fn default() -> Self {
        Self {
            header: Cow::Borrowed(""),
            framework_header: Cow::Borrowed(
                "// This file has been generated by Specta. DO NOT EDIT.",
            ),
            bigint: Default::default(),
        }
    }
}

impl Zod {
    /// Construct a new Zod exporter with the default options configured.
    pub fn new() -> Self {
        Default::default()
    }

    /// Override the header for the exported file.
    /// You should prefer `Self::header` instead unless your a framework.
    #[doc(hidden)]
    pub fn framework_header(mut self, header: impl Into<Cow<'static, str>>) -> Self {
        self.framework_header = header.into();
        self
    }

    /// Configure a header for the file.
    ///
    /// This is perfect for configuring lint ignore rules or other file-level comments.
    pub fn header(mut self, header: impl Into<Cow<'static, str>>) -> Self {
        self.header = header.into();
        self
    }

    /// Configure the BigInt handling behaviour
    pub fn bigint(mut self, bigint: BigIntExportBehavior) -> Self {
        self.bigint = bigint;
        self
    }

    /// Export the types into a single string.
    pub fn export(&self, types: &TypeCollection) -> Result<String, Error> {
        specta_serde::validate(types)?;

        // Check for duplicate type names
        let mut map = HashMap::with_capacity(types.len());
        for dt in types.into_unsorted_iter() {
            if let Some((existing_sid, existing_impl_location)) =
                map.insert(dt.name().clone(), (dt.sid(), dt.location()))
            {
                if existing_sid != dt.sid() {
                    return Err(Error::DuplicateTypeName {
                        types: (dt.location(), existing_impl_location),
                        name: dt.name().clone(),
                    });
                }
            }
        }

        let mut out = self.header.to_string();
        if !out.is_empty() {
            out.push('\n');
        }
        out += &self.framework_header;
        out.push_str("\n\n");

        for (i, ndt) in types.into_sorted_iter().enumerate() {
            if i != 0 {
                out += "\n\n";
            }

            out += &self.export_named_datatype(&ndt, types)?;
        }

        Ok(out)
    }

    /// Export the types to a specific file.
    pub fn export_to(&self, path: impl AsRef<Path>, types: &TypeCollection) -> Result<(), Error> {
        let path = path.as_ref();

        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }

        std::fs::write(path, self.export(types)?)?;

        Ok(())
    }

    /// Export a named data type to a Zod schema definition
    fn export_named_datatype(
        &self,
        ndt: &NamedDataType,
        types: &TypeCollection,
    ) -> Result<String, Error> {
        let ctx = ExportContext {
            cfg: self,
            path: vec![PathItem::Type(ndt.name().clone())],
            is_export: true,
        };

        let name = sanitise_type_name(ctx.clone(), NamedLocation::Type, ndt.name())?;

        let generics = if !ndt.generics().is_empty() {
            format!("<{}>", ndt.generics().join(", "))
        } else {
            String::new()
        };

        let schema = self.datatype_to_zod(ctx, ndt.ty(), types)?;

        Ok(format!("export const {name}{generics} = {schema}"))
    }

    /// Convert a DataType to a Zod schema
    fn datatype_to_zod(
        &self,
        ctx: ExportContext,
        dt: &DataType,
        types: &TypeCollection,
    ) -> Result<String, Error> {
        Ok(match dt {
            DataType::Primitive(p) => self.primitive_to_zod(&ctx, p)?,
            DataType::Literal(l) => {
                use specta::datatype::Literal::*;
                match l {
                    i8(v) => format!("z.literal({v})"),
                    i16(v) => format!("z.literal({v})"),
                    i32(v) => format!("z.literal({v})"),
                    u8(v) => format!("z.literal({v})"),
                    u16(v) => format!("z.literal({v})"),
                    u32(v) => format!("z.literal({v})"),
                    f32(v) => format!("z.literal({v})"),
                    f64(v) => format!("z.literal({v})"),
                    bool(v) => format!("z.literal({v})"),
                    String(v) => format!(r#"z.literal("{v}")"#),
                    char(v) => format!(r#"z.literal("{v}")"#),
                    None => "z.null()".to_string(),
                    _ => {
                        return Err(Error::Other(
                            ctx.export_path(),
                            "Unsupported literal type".to_string(),
                        ));
                    }
                }
            }
            DataType::Nullable(inner) => {
                let inner_zod = self.datatype_to_zod(ctx, inner, types)?;
                if inner_zod.ends_with(".nullable()") {
                    inner_zod
                } else {
                    format!("{inner_zod}.nullable()")
                }
            }
            DataType::Map(map) => {
                let key = self.datatype_to_zod(ctx.clone(), map.key_ty(), types)?;
                let value = self.datatype_to_zod(ctx, map.value_ty(), types)?;
                format!("z.record({key}, {value})")
            }
            DataType::List(list) => {
                let element = self.datatype_to_zod(ctx, list.ty(), types)?;
                if let Some(length) = list.length() {
                    let elements = (0..length)
                        .map(|_| element.clone())
                        .collect::<Vec<_>>()
                        .join(", ");
                    format!("z.tuple([{elements}])")
                } else {
                    format!("z.array({element})")
                }
            }
            DataType::Struct(s) => self.struct_to_zod(ctx, s, types)?,
            DataType::Enum(e) => self.enum_to_zod(ctx, e, types)?,
            DataType::Tuple(t) => {
                if t.elements().is_empty() {
                    "z.null()".to_string()
                } else {
                    let elements = t
                        .elements()
                        .iter()
                        .map(|elem| self.datatype_to_zod(ctx.clone(), elem, types))
                        .collect::<Result<Vec<_>, _>>()?
                        .join(", ");
                    format!("z.tuple([{elements}])")
                }
            }
            DataType::Reference(r) => {
                let ndt = types.get(r.sid()).ok_or_else(|| {
                    Error::Other(
                        ctx.export_path(),
                        format!("Missing type reference: {:?}", r.sid()),
                    )
                })?;

                if !r.generics().is_empty() {
                    let generics = r
                        .generics()
                        .iter()
                        .map(|(_, dt)| self.datatype_to_zod(ctx.clone(), dt, types))
                        .collect::<Result<Vec<_>, _>>()?
                        .join(", ");
                    format!("{}({})", ndt.name(), generics)
                } else {
                    ndt.name().to_string()
                }
            }
            DataType::Generic(g) => g.to_string(),
        })
    }

    fn primitive_to_zod(&self, ctx: &ExportContext, p: &Primitive) -> Result<String, Error> {
        use Primitive::*;
        Ok(match p {
            i8 | i16 | i32 | u8 | u16 | u32 | f32 | f64 | f16 => "z.number()".to_string(),
            usize | isize | i64 | u64 | i128 | u128 => match self.bigint {
                BigIntExportBehavior::String => "z.string()".to_string(),
                BigIntExportBehavior::Number => "z.number()".to_string(),
                BigIntExportBehavior::BigInt => "z.bigint()".to_string(),
                BigIntExportBehavior::Fail => {
                    return Err(Error::BigIntForbidden(ctx.export_path()));
                }
                BigIntExportBehavior::FailWithReason(reason) => {
                    return Err(Error::Other(ctx.export_path(), reason.to_string()));
                }
            },
            Primitive::bool => "z.boolean()".to_string(),
            String | char => "z.string()".to_string(),
        })
    }

    fn struct_to_zod(
        &self,
        ctx: ExportContext,
        s: &specta::datatype::Struct,
        types: &TypeCollection,
    ) -> Result<String, Error> {
        match s.fields() {
            Fields::Unit => Ok("z.null()".to_string()),
            Fields::Unnamed(fields) => {
                let non_skipped: Vec<_> = fields
                    .fields()
                    .iter()
                    .filter(|f| f.ty().is_some())
                    .collect();

                if non_skipped.is_empty() {
                    return Ok("z.tuple([])".to_string());
                }

                if non_skipped.len() == 1 {
                    let field = non_skipped[0];
                    return self.datatype_to_zod(ctx, field.ty().unwrap(), types);
                }

                let elements = non_skipped
                    .iter()
                    .map(|f| self.datatype_to_zod(ctx.clone(), f.ty().unwrap(), types))
                    .collect::<Result<Vec<_>, _>>()?
                    .join(", ");
                Ok(format!("z.tuple([{elements}])"))
            }
            Fields::Named(fields) => {
                let non_skipped: Vec<_> = fields
                    .fields()
                    .iter()
                    .filter(|(_, f)| f.ty().is_some())
                    .collect();

                if non_skipped.is_empty() {
                    // For empty structs, return an empty record
                    return Ok("z.record(z.string(), z.never())".to_string());
                }

                let (flattened, non_flattened): (Vec<_>, Vec<_>) =
                    non_skipped.into_iter().partition(|(_, f)| f.flatten());

                let mut field_sections = Vec::new();

                // Handle flattened fields
                for (_, field) in flattened {
                    let ty = field.ty().unwrap();
                    field_sections.push(self.datatype_to_zod(ctx.clone(), ty, types)?);
                }

                // Handle non-flattened fields
                let mut unflattened_fields = Vec::new();
                for (key, field) in non_flattened {
                    let ty = field.ty().unwrap();
                    let field_key = sanitise_key(key.clone());
                    let field_schema =
                        self.datatype_to_zod(ctx.with(PathItem::Field(key.clone())), ty, types)?;

                    if field.optional() {
                        unflattened_fields.push(format!("{field_key}: {field_schema}.optional()"));
                    } else {
                        unflattened_fields.push(format!("{field_key}: {field_schema}"));
                    }
                }

                // Note: For named structs in Zod, we don't typically add the tag like TypeScript
                // as Zod schemas are runtime validators, not types

                if !unflattened_fields.is_empty() {
                    if field_sections.is_empty() {
                        field_sections
                            .push(format!("z.object({{ {} }})", unflattened_fields.join(", ")));
                    } else {
                        field_sections.push(format!(
                            ".and(z.object({{ {} }}))",
                            unflattened_fields.join(", ")
                        ));
                    }
                }

                Ok(field_sections.join(""))
            }
        }
    }

    fn enum_to_zod(
        &self,
        ctx: ExportContext,
        e: &specta::datatype::Enum,
        types: &TypeCollection,
    ) -> Result<String, Error> {
        let variants: Vec<_> = e.variants().iter().filter(|(_, v)| !v.skip()).collect();

        if variants.is_empty() {
            return Ok("z.never()".to_string());
        }

        let variant_schemas = variants
            .iter()
            .map(|(name, variant)| {
                let ctx = ctx.with(PathItem::Variant(name.clone()));
                match e.repr() {
                    Some(EnumRepr::Untagged) => match variant.fields() {
                        Fields::Unit => Ok("z.null()".to_string()),
                        fields => self.enum_variant_fields_to_zod(ctx, name, fields, types),
                    },
                    Some(EnumRepr::External) | Some(EnumRepr::String { .. }) | None => match variant.fields() {
                        Fields::Unit => {
                            let sanitised_name = sanitise_key(name.clone());
                            Ok(format!("z.literal({sanitised_name})"))
                        }
                        Fields::Unnamed(f) if f.fields().iter().filter(|f| f.ty().is_some()).count() == 0 => {
                            let sanitised_name = sanitise_key(name.clone());
                            if f.fields().is_empty() {
                                let key = sanitise_key(name.clone());
                                Ok(format!("z.object({{ {key}: z.tuple([]) }})"))
                            } else {
                                Ok(format!("z.literal({sanitised_name})"))
                            }
                        }
                        fields => {
                            let key = sanitise_key(name.clone());
                            let value = self.enum_variant_fields_to_zod(ctx, name, fields, types)?;
                            Ok(format!("z.object({{ {key}: {value} }})"))
                        }
                    },
                    Some(EnumRepr::Internal { tag }) => {
                        let tag = sanitise_key(tag.clone());
                        let sanitised_name = sanitise_key(name.clone());
                        match variant.fields() {
                            Fields::Unit => {
                                Ok(format!("z.object({{ {tag}: z.literal({sanitised_name}) }})"))
                            }
                            fields => {
                                let fields_schema = self.enum_variant_fields_to_zod(ctx, name, fields, types)?;
                                Ok(format!(
                                    "z.object({{ {tag}: z.literal({sanitised_name}) }}).and({fields_schema})"
                                ))
                            }
                        }
                    }
                    Some(EnumRepr::Adjacent { tag, content }) => {
                        let tag = sanitise_key(tag.clone());
                        let sanitised_name = sanitise_key(name.clone());
                        match variant.fields() {
                            Fields::Unit => {
                                Ok(format!("z.object({{ {tag}: z.literal({sanitised_name}) }})"))
                            }
                            fields => {
                                let content_key = sanitise_key(content.clone());
                                let fields_schema = self.enum_variant_fields_to_zod(ctx, name, fields, types)?;
                                Ok(format!(
                                    "z.object({{ {tag}: z.literal({sanitised_name}), {content_key}: {fields_schema} }})"
                                ))
                            }
                        }
                    }
                }
            })
            .collect::<Result<Vec<_>, _>>()?;

        if variant_schemas.len() == 1 {
            Ok(variant_schemas[0].clone())
        } else {
            Ok(format!("z.union([{}])", variant_schemas.join(", ")))
        }
    }

    fn enum_variant_fields_to_zod(
        &self,
        ctx: ExportContext,
        _variant_name: &Cow<'static, str>,
        fields: &Fields,
        types: &TypeCollection,
    ) -> Result<String, Error> {
        match fields {
            Fields::Unit => Ok("z.null()".to_string()),
            Fields::Unnamed(f) => {
                let non_skipped: Vec<_> = f
                    .fields()
                    .iter()
                    .filter(|field| field.ty().is_some())
                    .collect();

                if non_skipped.is_empty() {
                    return Ok("z.tuple([])".to_string());
                }

                if non_skipped.len() == 1 {
                    return self.datatype_to_zod(ctx, non_skipped[0].ty().unwrap(), types);
                }

                let elements = non_skipped
                    .iter()
                    .map(|field| self.datatype_to_zod(ctx.clone(), field.ty().unwrap(), types))
                    .collect::<Result<Vec<_>, _>>()?
                    .join(", ");
                Ok(format!("z.tuple([{elements}])"))
            }
            Fields::Named(f) => {
                let non_skipped: Vec<_> = f
                    .fields()
                    .iter()
                    .filter(|(_, field)| field.ty().is_some())
                    .collect();

                if non_skipped.is_empty() {
                    return Ok("z.record(z.string(), z.never())".to_string());
                }

                let fields_str = non_skipped
                    .iter()
                    .map(|(key, field)| -> Result<String, Error> {
                        let ty = field.ty().unwrap();
                        let field_key = sanitise_key(key.clone());
                        let field_schema = self.datatype_to_zod(
                            ctx.with(PathItem::Field(key.clone())),
                            ty,
                            types,
                        )?;

                        if field.optional() {
                            Ok(format!("{field_key}: {field_schema}.optional()"))
                        } else {
                            Ok(format!("{field_key}: {field_schema}"))
                        }
                    })
                    .collect::<Result<Vec<_>, _>>()?
                    .join(", ");

                Ok(format!("z.object({{ {fields_str} }})"))
            }
        }
    }
}

fn sanitise_key(key: Cow<'static, str>) -> String {
    let valid = key
        .chars()
        .all(|c| c.is_alphanumeric() || c == '_' || c == '$')
        && key
            .chars()
            .next()
            .map(|first| !first.is_numeric())
            .unwrap_or(true);

    if !valid {
        format!(r#""{key}""#)
    } else {
        key.to_string()
    }
}

fn sanitise_type_name(
    ctx: ExportContext,
    loc: NamedLocation,
    ident: &str,
) -> Result<String, Error> {
    if let Some(first_char) = ident.chars().next() {
        if !first_char.is_alphabetic() && first_char != '_' {
            return Err(Error::InvalidName(
                loc,
                ctx.export_path(),
                ident.to_string(),
            ));
        }
    }

    if ident
        .find(|c: char| !c.is_alphanumeric() && c != '_')
        .is_some()
    {
        return Err(Error::InvalidName(
            loc,
            ctx.export_path(),
            ident.to_string(),
        ));
    }

    Ok(ident.to_string())
}
