---
source: tests2/tests/typescript.rs
expression: "dts.iter().map(|(s, ty)|\nprimitives::inline(&ts, &types,\nty).map(|ty| format!(\"{s}: {ty}\"))).collect::<Result<Vec<_>,\n_>>().unwrap().join(\"\\n\")"
---
i8: number
i16: number
i32: number
i64: number
i128: number
isize: number
u8: number
u16: number
u32: number
u64: number
u128: number
usize: number
f32: number
f64: number
bool: boolean
char: string
Range<i32>: { 
	start: number,
	end: number,
}
RangeInclusive<i32>: { 
	start: number,
	end: number,
}
(): null
(String, i32): [string, number]
(String, i32, bool): [string, number, boolean]
(bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool, bool): [boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean]
String: string
PathBuf: string
IpAddr: string
Ipv4Addr: string
Ipv6Addr: string
SocketAddr: string
SocketAddrV4: string
SocketAddrV6: string
SystemTime: { 
	duration_since_epoch: number,
	duration_since_unix_epoch: number,
}
Duration: { 
	secs: number,
	nanos: number,
}
&'static str: string
&'static bool: boolean
&'static i32: number
Vec<i32>: number[]
&'static [i32]: number[]
&'static [i32; 3]: [number, number, number]
Vec<MyEnum>: MyEnum[]
&'static [MyEnum]: MyEnum[]
&'static [MyEnum; 6]: [MyEnum, MyEnum, MyEnum, MyEnum, MyEnum, MyEnum]
&'static [i32; 1]: [number]
&'static [i32; 0]: []
Option<i32>: number | null
Option<()>: null | null
Unit1: null
Unit2: Record<string, never>
Unit3: []
Unit4: null
Unit5: "A"
Unit6: { A: [] }
Unit7: { A: Record<string, never> }
SimpleStruct: { 
	a: number,
	b: string,
	c: [number, string, number],
	d: string[],
	e: string | null,
}
TupleStruct1: number
TupleStruct3: [number, boolean, string]
TestEnum: "Unit" | { Single: number } | { Multiple: [number, number] } | { Struct: { a: number } }
RefStruct: TestEnum
InlinerStruct: { 
	inline_this: InlineStruct,
	dont_inline_this: RefStruct,
}
GenericStruct<i32>: { 
	arg: T,
}
GenericStruct<String>: { 
	arg: T,
}
FlattenEnumStruct: (FlattenEnum) & { 
	outer: string,
}
OverridenStruct: { 
	overriden_field: string,
}
HasGenericAlias: { [key in number]: string }
SkipVariant: { A: string }
SkipVariant2: string
SkipVariant3: { A: { a: string } }
EnumMacroAttributes: { A: string } | { B: number } | { C: number } | { D: { a: string; b: number } }
Recursive: { 
	a: number,
	children: Recursive[],
}
InlineEnumField: { A: PlaceholderInnerField }
InlineOptionalType: { 
	optional_field: PlaceholderInnerField | null,
}
Rename: "OneWord" | "TwoWords"
TransparentType: TransparentTypeInner
TransparentType2: null
TransparentTypeWithOverride: string
[Option<u8>; 3]: [(number | null), (number | null), (number | null)]
HashMap<BasicEnum, ()>: Partial<{ [key in BasicEnum]: null }>
Option<Option<Option<Option<i32>>>>: number | null
Vec<PlaceholderInnerField>: PlaceholderInnerField[]
HashMap<BasicEnum, i32>: Partial<{ [key in BasicEnum]: number }>
EnumReferenceRecordKey: { 
	a: Partial<{ [key in BasicEnum]: number }>,
}
FlattenOnNestedEnum: (NestedEnum) & { 
	id: string,
}
PhantomData<()>: null
PhantomData<String>: null
Infallible: never
MyEmptyInput: Record<string, never>
(String): string
(String,): [string]
ExtraBracketsInTupleVariant: { A: string }
ExtraBracketsInUnnamedStruct: string
Vec<MyEnum>: MyEnum[]
InlineTuple: { 
	demo: [string, boolean],
}
InlineTuple2: { 
	demo: [InlineTuple, boolean],
}
Box<str>: string
Box<String>: string
SkippedFieldWithinVariant: never | string
KebabCase: { 
	test_ing: string,
}
&[&str]: string[]
Issue281<'_>: { 
	default_unity_arguments: string[],
}
RenameWithWeirdCharsField: { 
	odata_context: string,
}
RenameWithWeirdCharsVariant: { A: string }
Issue374: { 
	foo: boolean,
	bar: boolean,
}
type_type::Type: never
