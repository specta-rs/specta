use std::{
    borrow::Cow,
    cell::RefCell,
    collections::{BTreeMap, BTreeSet, HashMap, HashSet},
    fmt,
    path::{Path, PathBuf},
    sync::Arc,
};

use specta::{
    TypeCollection,
    datatype::{DataType, Fields, NamedDataType, Reference},
};
use specta_serde::SerdeMode;

use crate::{Error, exporter, primitives};

thread_local! {
    static HAS_MANUALLY_EXPORTED_USER_TYPES: RefCell<bool> = const { RefCell::new(false) };
}

/// Allows you to configure how Specta's Typescript exporter will deal with BigInt types ([i64], [i128] etc).
///
/// WARNING: None of these settings affect how your data is actually ser/deserialized.
/// It's up to you to adjust your ser/deserialize settings.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]
pub enum BigIntExportBehavior {
    /// Export BigInt as a Typescript `string`
    ///
    /// Doing this in serde is [pretty simple](https://github.com/serde-rs/json/issues/329#issuecomment-305608405).
    String,
    /// Export BigInt as a Typescript `number`.
    ///
    /// WARNING: `JSON.parse` in JS will truncate your number resulting in data loss so ensure your deserializer supports large numbers.
    Number,
    /// Export BigInt as a Typescript `BigInt`.
    ///
    /// You must ensure you deserializer is able to support this.
    BigInt,
    /// Abort the export with an error.
    ///
    /// This is the default behavior because without integration from your serializer and deserializer we can't guarantee data loss won't occur.
    #[default]
    Fail,
}

/// Allows configuring the format of the final types file
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]
pub enum Layout {
    /// Produce a Typescript namespace for each Rust module
    Namespaces,
    /// Produce a dedicated file for each Rust module
    Files,
    /// Include the full module path in the types name but keep a flat structure.
    ModulePrefixedName,
    /// Flatten all of the types into a single file of types.
    /// This mode doesn't support having multiple types with the same name.
    #[default]
    FlatFile,
}

impl fmt::Display for Layout {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{self:?}")
    }
}

#[derive(Clone)]
struct RuntimeFn(Arc<dyn Fn(&Exporter, &TypeCollection) -> Result<Cow<'static, str>, Error>>);

impl fmt::Debug for RuntimeFn {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "RuntimeFn({:p})", self.0)
    }
}

/// Typescript language exporter.
#[derive(Debug, Clone)]
#[non_exhaustive]
pub struct Exporter {
    pub header: Cow<'static, str>,
    framework_runtime: Option<RuntimeFn>,
    framework_prelude: Cow<'static, str>,
    pub bigint: BigIntExportBehavior,
    pub layout: Layout,
    pub serde: Option<SerdeMode>,
    pub(crate) jsdoc: bool,
}

impl Exporter {
    // You should get this from either a [Typescript] or [JSDoc], not construct it directly.
    pub(crate) fn default() -> Exporter {
        Exporter {
            header: Cow::Borrowed(""),
            framework_runtime: None,
            framework_prelude: Cow::Borrowed(
                "// This file has been generated by Specta. Do not edit this file manually.",
            ),
            bigint: Default::default(),
            layout: Default::default(),
            serde: Some(SerdeMode::Both),
            jsdoc: false,
        }
    }

    /// Provide a prelude which is added to the start of all exported files.
    pub fn framework_prelude(mut self, prelude: impl Into<Cow<'static, str>>) -> Self {
        self.framework_prelude = prelude.into();
        self
    }

    /// Add some custom Typescript or Javascript code that is exported as part of the bindings.
    /// It's appending to the types file for single-file layouts or put in a root `index.{ts/js}` for multi-file.
    ///
    /// The closure is wrapped in [`specta::datatype::collect()`] to capture any referenced types.
    /// Ensure you call `T::reference()` within the closure if you want an import to be created.
    pub fn framework_runtime(
        mut self,
        builder: impl Fn(&Exporter, &TypeCollection) -> Result<Cow<'static, str>, Error> + 'static,
    ) -> Self {
        self.framework_runtime = Some(RuntimeFn(Arc::new(builder)));
        self
    }

    /// Configure a header for the file.
    ///
    /// This is perfect for configuring lint ignore rules or other file-level comments.
    pub fn header(mut self, header: impl Into<Cow<'static, str>>) -> Self {
        self.header = header.into();
        self
    }

    /// Configure the BigInt handling behaviour
    pub fn bigint(mut self, bigint: BigIntExportBehavior) -> Self {
        self.bigint = bigint;
        self
    }

    /// Configure the bindings layout
    pub fn layout(mut self, layout: Layout) -> Self {
        self.layout = layout;
        self
    }

    /// Configure the exporter to use specta-serde with the specified mode
    pub fn with_serde(mut self, mode: SerdeMode) -> Self {
        self.serde = Some(mode);
        self
    }

    /// Configure the exporter to export the types for `#[derive(serde::Serialize)]`
    pub fn with_serde_serialize(self) -> Self {
        self.with_serde(SerdeMode::Serialize)
    }

    /// Configure the exporter to export the types for `#[derive(serde::Deserialize)]`
    pub fn with_serde_deserialize(self) -> Self {
        self.with_serde(SerdeMode::Deserialize)
    }

    /// Export the files into a single string.
    ///
    /// Note: This will return [`Error::UnableToExport`](crate::Error::UnableToExport) if the format is `Format::Files`.
    pub fn export(&self, types: &TypeCollection) -> Result<String, Error> {
        let types = if let Some(mode) = self.serde {
            let mut types = types.clone(); // TODO: Can we avoid this?
            specta_serde::apply(&mut types, mode)?;
            Cow::Owned(types)
        } else {
            Cow::Borrowed(types)
        };

        match self.layout {
            Layout::ModulePrefixedName | Layout::Namespaces => {}
            Layout::Files => return Err(Error::UnableToExport),
            Layout::FlatFile => {
                let mut map = HashMap::with_capacity(types.len());
                for dt in types.into_unsorted_iter() {
                    if let Some(existing_dt) = map.insert(dt.name().clone(), dt)
                        && existing_dt != dt
                    {
                        return Err(Error::DuplicateTypeName {
                            types: (dt.location(), existing_dt.location()),
                            name: dt.name().clone(),
                        });
                    }
                }
            }
        };

        let mut out = self.header.to_string();
        if !self.header.is_empty() {
            out += "\n";
        }

        out += &self.framework_prelude;
        if !self.framework_prelude.is_empty() {
            out += "\n\n";
        }

        let mut requires_user_types = true;
        let mut runtime = Ok(Cow::default());
        if let Some(framework_runtime) = &self.framework_runtime {
            let runtime_references = primitives::collect_references(|| {
                HAS_MANUALLY_EXPORTED_USER_TYPES.set(false);
                runtime = (framework_runtime.0)(self, &types);
                requires_user_types = !HAS_MANUALLY_EXPORTED_USER_TYPES.replace(false);
            });

            // TODO: We need to properly deduplicate references
            println!(
                "{:#?}",
                runtime_references
                    .iter()
                    .map(|r| r.get(&types).unwrap().name())
                    .collect::<Vec<_>>()
            );
            // TODO: runtime_references
        }
        let runtime = runtime?;

        // TODO: Should only need imports when `Layout::Files`???
        // TODO: Check our reference generation is up to spec

        // Framework runtime
        out += &runtime;
        if !runtime.is_empty() {
            out += "\n";
        }

        // User types (if not included in framework runtime)
        if requires_user_types {
            render_types(&mut out, self, &types)?;
        }

        Ok(out)
    }

    /// Export the types to a specific file/folder.
    ///
    /// When configured when `format` is `Format::Files`, you must provide a directory path.
    /// Otherwise, you must provide the path of a single file.
    ///
    pub fn export_to(&self, path: impl AsRef<Path>, types: &TypeCollection) -> Result<(), Error> {
        let path = path.as_ref();

        if self.layout != Layout::Files {
            let result = self.export(types)?;
            if let Some(parent) = path.parent() {
                std::fs::create_dir_all(parent)?;
            };
            std::fs::write(path, result)?;
            return Ok(());
        }

        // TODO: Generate file before doing FS operations

        todo!();
        // let processed_types = if let Some(mode) = self.serde {
        //     let mut types_clone = types.clone();
        //     specta_serde::apply(&mut types_clone, mode)?;
        //     types_clone
        // } else {
        //     types.clone()
        // };
        // let types = &processed_types;

        // std::fs::create_dir_all(path)?;

        // let mut files = HashMap::<PathBuf, Vec<NamedDataType>>::new();

        // for ndt in types.into_sorted_iter() {
        //     let mut path = PathBuf::from(path);
        //     for m in ndt.module_path().split("::") {
        //         path = path.join(m);
        //     }
        //     path.set_extension(if self.jsdoc { "js" } else { "ts" });
        //     files.entry(path).or_default().push(ndt);
        // }

        // let mut used_paths = files.keys().cloned().collect::<HashSet<_>>();

        // for (path, ndts) in files {
        //     if let Some(parent) = path.parent() {
        //         std::fs::create_dir_all(parent)?;
        //     }

        //     let mut references = ImportMap::default();
        //     for ndt in ndts.iter() {
        //         crawl_for_imports(ndt.ty(), types, &mut references);
        //     }

        //     std::fs::write(
        //         &path,
        //         self.export_internal(ndts.into_iter(), Some(references), types, false)?,
        //     )?;
        // }

        // if let Some(framework_runtime) = &self.framework_runtime {
        //     // TODO: Does this risk conflicting with an `index.rs` module???
        //     let p = path.join(if self.jsdoc { "index.js" } else { "index.ts" });

        //     let mut content = self.framework_prelude.to_string();
        //     if !self.framework_prelude.is_empty() {
        //         content.push('\n');
        //     }

        //     let mut runtime = Cow::default();
        //     let runtime_references = primitives::collect_references(|| {
        //         todo!();
        //         // runtime = (framework_runtime.0)(self, "// Hello World\n".into()); // TODO: Fix this
        //     });

        //     let mut runtime_imports = ImportMap::default();
        //     for r in runtime_references {
        //         if let Some(ndt) = r.get(types) {
        //             crawl_for_imports(ndt.ty(), types, &mut runtime_imports);
        //         }
        //     }

        //     // Add imports
        //     if !runtime_imports.is_empty() {
        //         if self.jsdoc {
        //             content.push_str("\n/**");
        //         }

        //         for (src, items) in &runtime_imports {
        //             if self.jsdoc {
        //                 content.push_str("\n\t* @import");
        //             } else {
        //                 content.push_str("\nimport type");
        //             }

        //             content.push_str(" { ");
        //             for (i, (name, alias)) in items.iter().enumerate() {
        //                 if i != 0 {
        //                     content.push_str(", ");
        //                 }
        //                 content.push_str(name);
        //                 if alias != name {
        //                     content.push_str(" as ");
        //                     content.push_str(alias);
        //                 }
        //             }

        //             content.push_str(" } from \"");
        //             content.push_str(src);
        //             content.push_str("\";");
        //         }

        //         if self.jsdoc {
        //             content.push_str("\n\t*/");
        //         }
        //         content.push_str("\n\n");
        //     }

        //     content.push_str(&runtime);
        //     if !runtime.is_empty() {
        //         content.push('\n');
        //     }

        //     std::fs::write(&p, content)?;

        //     // This is to ensure `remove_unused_ts_files` doesn't remove it
        //     used_paths.insert(p);
        // }

        // if path.exists() && path.is_dir() {
        //     fn remove_unused_ts_files(
        //         dir: &Path,
        //         used_paths: &HashSet<PathBuf>,
        //     ) -> std::io::Result<()> {
        //         for entry in std::fs::read_dir(dir)? {
        //             let entry = entry?;
        //             let entry_path = entry.path();

        //             if entry_path.is_dir() {
        //                 remove_unused_ts_files(&entry_path, used_paths)?;

        //                 // Remove empty directories
        //                 if std::fs::read_dir(&entry_path)?.next().is_none() {
        //                     std::fs::remove_dir(&entry_path)?;
        //                 }
        //             } else if matches!(
        //                 entry_path.extension().and_then(|ext| ext.to_str()),
        //                 Some("ts" | "js")
        //             ) && !used_paths.contains(&entry_path)
        //             {
        //                 std::fs::remove_file(&entry_path)?;
        //             }
        //         }
        //         Ok(())
        //     }

        //     let _ = remove_unused_ts_files(path, &used_paths);
        // }

        Ok(())
    }

    /// Render the types within the [TypeCollection].
    ///
    /// This will only work if used within [Self::framework_runtime] function.
    /// It allows frameworks to intersperse their user types into their runtime code.
    pub fn render_types(&self, types: &TypeCollection) -> Result<Cow<'static, str>, Error> {
        let mut s = String::new();
        render_types(&mut s, self, types)?;
        HAS_MANUALLY_EXPORTED_USER_TYPES.set(true);
        Ok(Cow::Owned(s))
    }
}

impl AsRef<Exporter> for Exporter {
    fn as_ref(&self) -> &Exporter {
        self
    }
}

impl AsMut<Exporter> for Exporter {
    fn as_mut(&mut self) -> &mut Exporter {
        self
    }
}

#[derive(Default)]
struct Namespace<'a> {
    types: Vec<&'a NamedDataType>,
    children: BTreeMap<&'a str, Namespace<'a>>,
}

fn render_types(s: &mut String, exporter: &Exporter, types: &TypeCollection) -> Result<(), Error> {
    match exporter.layout {
        Layout::Namespaces => {
            fn export(
                exporter: &Exporter,
                types: &TypeCollection,
                s: &mut String,
                ns: &mut Namespace,
                depth: usize,
            ) -> Result<(), Error> {
                let indent = "\t".repeat(depth);

                ns.types.sort_by(|a, b| {
                    a.name()
                        .cmp(b.name())
                        .then(a.module_path().cmp(b.module_path()))
                        .then(a.location().cmp(&b.location()))
                });
                for ndt in &ns.types {
                    s.push('\n');
                    s.push_str(&indent);

                    if exporter.jsdoc {
                        // TODO: Don't allocate local string
                        s.push_str(&primitives::typedef_internal(exporter, types, ndt)?);
                    } else {
                        // TODO: Don't allocate local string
                        s.push_str(&primitives::export(exporter, types, ndt)?);
                    }
                }

                for (name, ns) in &mut ns.children {
                    s.push('\n');
                    s.push_str(&indent);
                    s.push_str("export namespace ");
                    s.push_str(name);
                    s.push_str(" {\n");
                    export(exporter, types, s, ns, depth + 1)?;
                    s.push_str("}\n");
                }

                Ok(())
            }

            export(
                exporter,
                types,
                s,
                &mut types
                    .into_unsorted_iter()
                    .fold(Namespace::default(), |mut ns, ndt| {
                        let path = ndt.module_path();

                        if path.is_empty() {
                            ns.types.push(ndt);
                        } else {
                            let mut current = &mut ns;
                            for segment in path.split("::") {
                                current = current.children.entry(segment).or_default();
                            }

                            current.types.push(ndt);
                        }

                        ns
                    }),
                0,
            )?;
        }
        Layout::ModulePrefixedName | Layout::FlatFile => {
            for ndt in types.into_sorted_iter() {
                s.push('\n');

                if exporter.jsdoc {
                    // TODO: Don't allocate local string
                    s.push_str(&primitives::typedef_internal(exporter, types, &ndt)?);
                } else {
                    // TODO: Don't allocate local string
                    s.push_str(&primitives::export(exporter, types, &ndt)?);
                }
            }
        }
        // The types will get their own files
        // So we keep the user types empty for easy downstream detection.
        Layout::Files => {}
    }

    Ok(())
}

pub(crate) fn root_alias_ident(root: &str) -> String {
    let mut alias = String::from("$specta$root$");
    for ch in root.chars() {
        if ch == '_' || ch.is_ascii_alphanumeric() {
            alias.push(ch);
        } else {
            alias.push('_');
        }
    }
    alias.push('$');
    alias
}
