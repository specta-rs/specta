use std::{
    borrow::Cow,
    collections::{BTreeMap, HashMap, HashSet},
    fmt,
    ops::Deref,
    panic::Location,
    path::{Path, PathBuf},
    sync::Arc,
};

use specta::{
    TypeCollection,
    datatype::{DataType, NamedDataType, Reference},
};
use specta_serde::SerdeMode;

use crate::{Error, TypeOrModuleOrImport, primitives};

/// Allows you to configure how Specta's Typescript exporter will deal with BigInt types ([i64], [i128] etc).
///
/// WARNING: None of these settings affect how your data is actually ser/deserialized.
/// It's up to you to adjust your ser/deserialize settings.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]
pub enum BigIntExportBehavior {
    /// Export BigInt as a Typescript `string`
    ///
    /// Doing this in serde is [pretty simple](https://github.com/serde-rs/json/issues/329#issuecomment-305608405).
    String,
    /// Export BigInt as a Typescript `number`.
    ///
    /// WARNING: `JSON.parse` in JS will truncate your number resulting in data loss so ensure your deserializer supports large numbers.
    Number,
    /// Export BigInt as a Typescript `BigInt`.
    ///
    /// You must ensure you deserializer is able to support this.
    BigInt,
    /// Abort the export with an error.
    ///
    /// This is the default behavior because without integration from your serializer and deserializer we can't guarantee data loss won't occur.
    #[default]
    Fail,
}

/// Allows configuring the format of the final types file
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]
pub enum Layout {
    /// Produce a Typescript namespace for each Rust module
    Namespaces,
    /// Produce a dedicated file for each Rust module
    Files,
    /// Include the full module path in the types name but keep a flat structure.
    ModulePrefixedName,
    /// Flatten all of the types into a single file of types.
    /// This mode doesn't support having multiple types with the same name.
    #[default]
    FlatFile,
}

impl fmt::Display for Layout {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{self:?}")
    }
}

#[derive(Clone)]
#[allow(clippy::type_complexity)]
struct RuntimeFn(Arc<dyn Fn(FrameworkExporter) -> Result<Cow<'static, str>, Error>>);

impl fmt::Debug for RuntimeFn {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "RuntimeFn({:p})", self.0)
    }
}

/// Typescript language exporter.
#[derive(Debug, Clone)]
#[non_exhaustive]
pub struct Exporter {
    pub header: Cow<'static, str>,
    framework_runtime: Option<RuntimeFn>,
    framework_prelude: Cow<'static, str>,
    pub bigint: BigIntExportBehavior,
    pub layout: Layout,
    pub serde: Option<SerdeMode>,
    pub(crate) jsdoc: bool,
}

impl Exporter {
    // You should get this from either a [Typescript] or [JSDoc], not construct it directly.
    pub(crate) fn default() -> Exporter {
        Exporter {
            header: Cow::Borrowed(""),
            framework_runtime: None,
            framework_prelude: Cow::Borrowed(
                "// This file has been generated by Specta. Do not edit this file manually.",
            ),
            bigint: Default::default(),
            layout: Default::default(),
            serde: Some(SerdeMode::Both),
            jsdoc: false,
        }
    }

    /// Provide a prelude which is added to the start of all exported files.
    pub fn framework_prelude(mut self, prelude: impl Into<Cow<'static, str>>) -> Self {
        self.framework_prelude = prelude.into();
        self
    }

    /// Add some custom Typescript or Javascript code that is exported as part of the bindings.
    /// It's appending to the types file for single-file layouts or put in a root `index.{ts/js}` for multi-file.
    ///
    /// The closure is wrapped in [`specta::datatype::collect()`] to capture any referenced types.
    /// Ensure you call `T::reference()` within the closure if you want an import to be created.
    pub fn framework_runtime(
        mut self,
        builder: impl Fn(FrameworkExporter) -> Result<Cow<'static, str>, Error> + 'static,
    ) -> Self {
        self.framework_runtime = Some(RuntimeFn(Arc::new(builder)));
        self
    }

    /// Configure a header for the file.
    ///
    /// This is perfect for configuring lint ignore rules or other file-level comments.
    pub fn header(mut self, header: impl Into<Cow<'static, str>>) -> Self {
        self.header = header.into();
        self
    }

    /// Configure the BigInt handling behaviour
    pub fn bigint(mut self, bigint: BigIntExportBehavior) -> Self {
        self.bigint = bigint;
        self
    }

    /// Configure the bindings layout
    pub fn layout(mut self, layout: Layout) -> Self {
        self.layout = layout;
        self
    }

    /// Configure the exporter to use specta-serde with the specified mode
    pub fn with_serde(mut self, mode: SerdeMode) -> Self {
        self.serde = Some(mode);
        self
    }

    /// Configure the exporter to export the types for `#[derive(serde::Serialize)]`
    pub fn with_serde_serialize(self) -> Self {
        self.with_serde(SerdeMode::Serialize)
    }

    /// Configure the exporter to export the types for `#[derive(serde::Deserialize)]`
    pub fn with_serde_deserialize(self) -> Self {
        self.with_serde(SerdeMode::Deserialize)
    }

    /// Export the files into a single string.
    ///
    /// Note: This will return [`Error::UnableToExport`](crate::Error::UnableToExport) if the format is `Format::Files`.
    pub fn export(&self, types: &TypeCollection) -> Result<String, Error> {
        let types = if let Some(mode) = self.serde {
            let mut types = types.clone(); // TODO: Can we avoid this?
            specta_serde::apply(&mut types, mode)?;
            Cow::Owned(types)
        } else {
            Cow::Borrowed(types)
        };

        if let Layout::Files = self.layout {
            return Err(Error::UnableToExport);
        }

        let mut out = render_file_header(self)?;

        let mut has_manually_exported_user_types = false;
        let mut runtime = Ok(Cow::default());
        if let Some(framework_runtime) = &self.framework_runtime {
            runtime = (framework_runtime.0)(FrameworkExporter {
                exporter: self,
                has_manually_exported_user_types: &mut has_manually_exported_user_types,
                files_root_types: "",
                types: &types,
            });
        }
        let runtime = runtime?;

        // Framework runtime
        if !runtime.is_empty() {
            out += "\n";
        }
        out += &runtime;
        if !runtime.is_empty() {
            out += "\n";
        }

        // User types (if not included in framework runtime)
        if !has_manually_exported_user_types {
            render_types(&mut out, self, &types, "")?;
        }

        Ok(out)
    }

    /// Export the types to a specific file/folder.
    ///
    /// When configured when `format` is `Format::Files`, you must provide a directory path.
    /// Otherwise, you must provide the path of a single file.
    ///
    pub fn export_to(&self, path: impl AsRef<Path>, types: &TypeCollection) -> Result<(), Error> {
        let path = path.as_ref();

        if self.layout != Layout::Files {
            let result = self.export(types)?;
            if let Some(parent) = path.parent() {
                std::fs::create_dir_all(parent)?;
            };
            std::fs::write(path, result)?;
            return Ok(());
        }

        let types = if let Some(mode) = self.serde {
            let mut types = types.clone(); // TODO: Can we avoid this?
            specta_serde::apply(&mut types, mode)?;
            Cow::Owned(types)
        } else {
            Cow::Borrowed(types)
        };

        #[allow(clippy::too_many_arguments)]
        fn export(
            exporter: &Exporter,
            types: &TypeCollection,
            module: &mut Module,
            s: &mut String,
            path: &Path,
            parent_name: &str,
            files: &mut HashMap<PathBuf, String>,
            depth: usize,
        ) -> Result<(), Error> {
            // Types
            // for ndt in &module.types {
            //     // TODO: Make this only restrict the user when `framework` exists (Eg. whenever a reference exists in the current file).
            //     if ndt.name() == "framework" {
            //         return Err(Error::DuplicateTypeName {
            //             types: (
            //                 TypeOrModuleOrImport::Import("framework".into()),
            //                 ndt.location().into(),
            //             ),
            //             name: ndt.name().clone(),
            //         });
            //     }
            // }

            module.types.sort_by(|a, b| {
                a.name()
                    .cmp(b.name())
                    .then(a.module_path().cmp(b.module_path()))
                    .then(a.location().cmp(&b.location()))
            });
            let exports = render_flat_types(s, exporter, types, module.types.iter().copied(), "")?;

            if !module.children.is_empty() {
                for name in module.children.keys() {
                    // TODO: Make this only restrict the user when `framework` is used.
                    // if *name == "framework" {
                    //     return Err(Error::DuplicateTypeName {
                    //         types: (
                    //             TypeOrModuleOrImport::Import("framework".into()),
                    //             construct_module(&module.module_path, name),
                    //         ),
                    //         name: name.to_string().into(),
                    //     });
                    // } else
                    if let Some(other) = exports.get(*name) {
                        return Err(Error::DuplicateTypeName {
                            types: (construct_module(&module.module_path, name), (*other).into()),
                            name: name.to_string().into(),
                        });
                    }

                    s.push_str("\nimport type * as ");
                    s.push_str(name);
                    s.push_str(" from \"./");
                    if !parent_name.is_empty() {
                        s.push_str(parent_name);
                        s.push('/');
                    }
                    s.push_str(name);
                    s.push_str("\";");
                }

                s.push_str("\n\nexport type { ");
                for (i, name) in module.children.keys().enumerate() {
                    if i != 0 {
                        s.push_str(", ");
                    }
                    s.push_str(name);
                }
                s.push_str(" };\n");
            }

            for (name, module) in &mut module.children {
                let mut path = path.join(name);
                let mut out = render_file_header(exporter)?;

                // TODO: Only add this if it's used
                out.push_str("\nimport * as framework from \"");
                if depth == 0 {
                    out.push_str("./");
                } else {
                    for _ in 0..depth {
                        out.push_str("../");
                    }
                }
                out.push_str("index\";\n");

                export(
                    exporter,
                    types,
                    module,
                    &mut out,
                    &path,
                    name,
                    files,
                    depth + 1,
                )?;
                path.set_extension(if exporter.jsdoc { "js" } else { "ts" });
                files.insert(path, out);
            }

            Ok(())
        }

        let mut files = HashMap::new();
        let mut runtime_path = path.join("index");
        runtime_path.set_extension(if self.jsdoc { "js" } else { "ts" });

        let mut root_types = String::new();
        export(
            self,
            &types,
            &mut build_module_graph(&types),
            &mut root_types,
            path,
            "",
            &mut files,
            0,
        )?;

        {
            let mut has_manually_exported_user_types = false;
            let mut runtime = Cow::default();
            if let Some(framework_runtime) = &self.framework_runtime {
                runtime = (framework_runtime.0)(FrameworkExporter {
                    exporter: self,
                    has_manually_exported_user_types: &mut has_manually_exported_user_types,
                    files_root_types: &root_types,
                    types: &types,
                })?;
            }

            if !runtime.is_empty() {
                files.insert(runtime_path, {
                    let mut out = render_file_header(self)?;

                    // Framework runtime
                    out.push('\n');
                    out.push_str(&runtime);

                    // User types (if not included in framework runtime)
                    if !has_manually_exported_user_types {
                        if !runtime.is_empty() {
                            out += "\n";
                        }

                        render_types(&mut out, self, &types, "")?;
                    }

                    out
                });
            }
        }

        if let Ok(meta) = path.metadata()
            && !meta.is_dir()
        {
            std::fs::remove_file(path)?;
        }

        for (path, content) in &files {
            path.parent().map(std::fs::create_dir_all).transpose()?;
            std::fs::write(path, content)?;
        }

        cleanup_stale_files(path, &files)?;

        Ok(())
    }
}

impl AsRef<Exporter> for Exporter {
    fn as_ref(&self) -> &Exporter {
        self
    }
}

impl AsMut<Exporter> for Exporter {
    fn as_mut(&mut self) -> &mut Exporter {
        self
    }
}

/// Reference to Typescript language exporter for framework
pub struct FrameworkExporter<'a> {
    exporter: &'a Exporter,
    has_manually_exported_user_types: &'a mut bool,
    // For `Layout::Files` we need to inject the value
    files_root_types: &'a str,
    pub types: &'a TypeCollection,
}

impl fmt::Debug for FrameworkExporter<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.exporter.fmt(f)
    }
}

impl AsRef<Exporter> for FrameworkExporter<'_> {
    fn as_ref(&self) -> &Exporter {
        self
    }
}

impl Deref for FrameworkExporter<'_> {
    type Target = Exporter;

    fn deref(&self) -> &Self::Target {
        self.exporter
    }
}

impl FrameworkExporter<'_> {
    /// Render the types within the [TypeCollection].
    ///
    /// This will only work if used within [Self::framework_runtime] function.
    /// It allows frameworks to intersperse their user types into their runtime code.
    pub fn render_types(&mut self) -> Result<Cow<'static, str>, Error> {
        let mut s = String::new();
        render_types(&mut s, self.exporter, self.types, self.files_root_types)?;
        *self.has_manually_exported_user_types = true;
        Ok(Cow::Owned(s))
    }

    /// [primitives::export]
    pub fn export(&self, ndt: &NamedDataType) -> Result<String, Error> {
        primitives::export(self, self.types, ndt)
    }

    /// [primitives::inline]
    pub fn inline(&self, dt: &DataType) -> Result<String, Error> {
        primitives::inline(self, self.types, dt)
    }

    /// [primitives::reference]
    pub fn reference(&self, r: &Reference) -> Result<String, Error> {
        primitives::reference(self, self.types, r)
    }
}

struct Module<'a> {
    types: Vec<&'a NamedDataType>,
    children: BTreeMap<&'a str, Module<'a>>,
    module_path: Cow<'static, str>,
}

fn build_module_graph(types: &TypeCollection) -> Module<'_> {
    types.into_unsorted_iter().fold(
        Module {
            types: Default::default(),
            children: Default::default(),
            module_path: Default::default(),
        },
        |mut ns, ndt| {
            let path = ndt.module_path();

            if path.is_empty() {
                ns.types.push(ndt);
            } else {
                let mut current = &mut ns;
                for segment in path.split("::") {
                    current = current.children.entry(segment).or_insert_with(|| Module {
                        types: Default::default(),
                        children: Default::default(),
                        module_path: path.clone(),
                    });
                }

                current.types.push(ndt);
            }

            ns
        },
    )
}

fn render_file_header(exporter: &Exporter) -> Result<String, Error> {
    let mut out = exporter.header.to_string();
    if !exporter.header.is_empty() {
        out += "\n";
    }

    out += &exporter.framework_prelude;
    if !exporter.framework_prelude.is_empty() {
        out += "\n";
    }

    Ok(out)
}

fn render_types(
    s: &mut String,
    exporter: &Exporter,
    types: &TypeCollection,
    files_user_types: &str,
) -> Result<(), Error> {
    match exporter.layout {
        Layout::Namespaces => {
            fn export<'a>(
                exporter: &Exporter,
                types: &TypeCollection,
                s: &mut String,
                module: impl ExactSizeIterator<Item = (&'a &'a str, &'a mut Module<'a>)>,
                depth: usize,
            ) -> Result<(), Error> {
                let indent = "\t".repeat(depth);

                for (name, module) in module {
                    s.push('\n');
                    s.push_str(&indent);
                    if depth != 0 && *name != "$specta$" {
                        s.push_str("export ");
                    }
                    s.push_str("namespace ");
                    s.push_str(name);
                    s.push_str(" {\n");

                    // Types
                    module.types.sort_by(|a, b| {
                        a.name()
                            .cmp(b.name())
                            .then(a.module_path().cmp(b.module_path()))
                            .then(a.location().cmp(&b.location()))
                    });
                    render_flat_types(s, exporter, types, module.types.iter().copied(), &indent)?;

                    // Namespaces
                    export(exporter, types, s, module.children.iter_mut(), depth + 1)?;

                    s.push_str("}\n");
                }

                Ok(())
            }

            let mut module = build_module_graph(types);

            let reexports = {
                let mut reexports = String::new();
                for name in module
                    .children
                    .keys()
                    .cloned()
                    .chain(module.types.iter().map(|ndt| &**ndt.name()))
                {
                    reexports.push_str("export import ");
                    reexports.push_str(name);
                    reexports.push_str(" = $s$.");
                    reexports.push_str(name);
                    reexports.push_str(";\n");
                }
                reexports
            };

            export(exporter, types, s, [(&"$s$", &mut module)].into_iter(), 0)?;
            s.push_str(&reexports);
        }
        Layout::ModulePrefixedName | Layout::FlatFile => {
            render_flat_types(s, exporter, types, types.into_sorted_iter(), "")?;
        }
        // The types will get their own files
        // So we keep the user types empty for easy downstream detection.
        Layout::Files => {
            if !files_user_types.is_empty() {
                s.push_str(files_user_types);
            }
        }
    }

    Ok(())
}

// Implementation of `Layout::ModulePrefixedName | Layout::FlatFile`,
// but is used by `Layout::Namespace` and `Layout::Files`
fn render_flat_types<'a>(
    s: &mut String,
    exporter: &Exporter,
    types: &TypeCollection,
    ndts: impl ExactSizeIterator<Item = &'a NamedDataType>,
    indent: &str,
) -> Result<HashMap<String, Location<'static>>, Error> {
    let mut exports = HashMap::with_capacity(ndts.len());

    for ndt in ndts {
        if !ndt.requires_reference(types) {
            continue;
        }

        if let Some(other) = exports.insert(ndt.name().to_string(), ndt.location()) {
            return Err(Error::DuplicateTypeName {
                types: (ndt.location().into(), other.into()),
                name: ndt.name().clone(),
            });
        }

        s.push('\n');
        s.push_str(indent);

        if exporter.jsdoc {
            primitives::typedef_internal(s, exporter, types, ndt)?;
        } else {
            primitives::export_internal(s, exporter, types, ndt)?;
        }
    }

    Ok(exports)
}

/// Collect all TypeScript/JavaScript files in a directory recursively
fn collect_existing_files(root: &Path) -> Result<HashSet<PathBuf>, std::io::Error> {
    if !root.exists() {
        return Ok(HashSet::new());
    }

    Ok(std::fs::read_dir(root)?
        .filter_map(Result::ok)
        .flat_map(|entry| {
            let path = entry.path();
            if path.is_dir() {
                collect_existing_files(&path).unwrap_or_default()
            } else if matches!(path.extension().and_then(|e| e.to_str()), Some("ts" | "js")) {
                HashSet::from([path])
            } else {
                HashSet::new()
            }
        })
        .collect::<HashSet<_>>())
}

/// Remove empty directories recursively, stopping at the root
fn remove_empty_dirs(path: &Path, root: &Path) -> Result<(), std::io::Error> {
    std::fs::read_dir(path)?
        .filter_map(Result::ok)
        .filter(|entry| entry.path().is_dir())
        .try_for_each(|entry| remove_empty_dirs(&entry.path(), root))?;
    if path != root && path.read_dir()?.next().is_none() {
        std::fs::remove_dir(path)?;
    }
    Ok(())
}

/// Delete stale files and clean up empty directories
fn cleanup_stale_files(root: &Path, current_files: &HashMap<PathBuf, String>) -> Result<(), Error> {
    collect_existing_files(root)?
        .into_iter()
        .filter(|path| !current_files.contains_key(path))
        .try_for_each(|path| std::fs::remove_file(&path).map_err(Error::from))?;
    remove_empty_dirs(root, root).ok(); // Ignore errors for directory cleanup
    Ok(())
}

fn construct_module(path: &str, ident: &str) -> TypeOrModuleOrImport {
    TypeOrModuleOrImport::Module(
        if path.is_empty() {
            format!("::{ident}")
        } else {
            format!("{path}::{ident}")
        }
        .into(),
    )
}
