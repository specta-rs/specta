use std::{
    borrow::Cow,
    collections::{BTreeMap, BTreeSet, HashMap, HashSet},
    path::{Path, PathBuf},
};

use specta::{
    TypeCollection,
    datatype::{DataType, Fields, NamedDataType, Reference},
};

use crate::{Error, primitives, types};

/// Allows you to configure how Specta's Typescript exporter will deal with BigInt types ([i64], [i128] etc).
///
/// WARNING: None of these settings affect how your data is actually ser/deserialized.
/// It's up to you to adjust your ser/deserialize settings.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]
pub enum BigIntExportBehavior {
    /// Export BigInt as a Typescript `string`
    ///
    /// Doing this in serde is [pretty simple](https://github.com/serde-rs/json/issues/329#issuecomment-305608405).
    String,
    /// Export BigInt as a Typescript `number`.
    ///
    /// WARNING: `JSON.parse` in JS will truncate your number resulting in data loss so ensure your deserializer supports large numbers.
    Number,
    /// Export BigInt as a Typescript `BigInt`.
    ///
    /// You must ensure you deserializer is able to support this.
    BigInt,
    /// Abort the export with an error.
    ///
    /// This is the default behavior because without integration from your serializer and deserializer we can't guarantee data loss won't occur.
    #[default]
    Fail,
}

/// Allows configuring the format of the final types file
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]
pub enum Layout {
    /// Produce a Typescript namespace for each Rust module
    Namespaces,
    /// Produce a dedicated file for each Rust module
    Files,
    /// Include the full module path in the types name but keep a flat structure.
    ModulePrefixedName,
    /// Flatten all of the types into a single file of types.
    /// This mode doesn't support having multiple types with the same name.
    #[default]
    FlatFile,
}

/// Typescript language exporter.
#[derive(Debug, Clone)]
#[non_exhaustive]
pub struct Typescript {
    pub header: Cow<'static, str>,
    framework_runtime: Cow<'static, str>,
    framework_prelude: Cow<'static, str>,
    pub(crate) references: Vec<(Reference, Cow<'static, str>)>,
    pub bigint: BigIntExportBehavior,
    pub layout: Layout,
    pub serde: bool,
    pub(crate) jsdoc: bool,
}

impl Default for Typescript {
    fn default() -> Self {
        Self {
            header: Cow::Borrowed(""),
            framework_runtime: Cow::Borrowed(""),
            framework_prelude: Cow::Borrowed(
                "// This file has been generated by Specta. Do not edit this file manually.",
            ),
            references: vec![
                (types::ANY_REFERENCE.clone(), Cow::Borrowed("any")),
                (types::UNKNOWN_REFERENCE.clone(), Cow::Borrowed("unknown")),
                (types::NEVER_REFERENCE.clone(), Cow::Borrowed("never")),
            ],
            bigint: Default::default(),
            layout: Default::default(),
            serde: false,
            jsdoc: false,
        }
    }
}

impl Typescript {
    /// Construct a new Typescript exporter with the default options configured.
    pub fn new() -> Self {
        Default::default()
    }

    /// Define a custom Typescript type which can be injected in place of a `Reference`.
    ///
    /// This is an advanced feature which should be used with caution.
    pub fn define(&mut self, typescript: impl Into<Cow<'static, str>>) -> Reference {
        let reference = Reference::opaque();
        self.references.push((reference.clone(), typescript.into()));
        reference
    }
    /// Provide a prelude which is added to the start of all exported files.
    #[doc(hidden)]
    pub fn framework_prelude(mut self, prelude: impl Into<Cow<'static, str>>) -> Self {
        self.framework_prelude = prelude.into();
        self
    }

    /// Inject some code which is exported into the bindings file (or a root `index.ts` file).
    #[doc(hidden)]
    pub fn framework_runtime(mut self, runtime: impl Into<Cow<'static, str>>) -> Self {
        self.framework_runtime = runtime.into();
        self
    }

    /// Configure a header for the file.
    ///
    /// This is perfect for configuring lint ignore rules or other file-level comments.
    pub fn header(mut self, header: impl Into<Cow<'static, str>>) -> Self {
        self.header = header.into();
        self
    }

    /// Configure the BigInt handling behaviour
    pub fn bigint(mut self, bigint: BigIntExportBehavior) -> Self {
        self.bigint = bigint;
        self
    }

    /// Configure the bindings layout
    pub fn layout(mut self, layout: Layout) -> Self {
        self.layout = layout;
        self
    }

    /// TODO: Explain
    pub fn with_serde(mut self) -> Self {
        self.serde = true;
        self
    }

    /// Export the files into a single string.
    ///
    /// Note: This will return [`Error:UnableToExport`] if the format is `Format::Files`.
    pub fn export(&self, types: &TypeCollection) -> Result<String, Error> {
        if self.serde {
            specta_serde::validate(types)?;
        }

        match self.layout {
            Layout::Namespaces => {
                let mut out = self.export_internal([].into_iter(), None, types, true)?;
                let mut module_types: HashMap<_, Vec<_>> = HashMap::new();

                for ndt in types.into_unsorted_iter() {
                    module_types
                        .entry(ndt.module_path().to_string())
                        .or_default()
                        .push(ndt.clone());
                }

                // Group all modules by their root namespace (first segment)
                let mut root_namespaces: HashMap<String, Vec<String>> = HashMap::new();

                for module_path in module_types.keys() {
                    if let Some(root) = module_path.split("::").next() {
                        root_namespaces
                            .entry(root.to_string())
                            .or_default()
                            .push(module_path.clone());
                    }
                }

                // Sort root namespaces for consistent output
                let mut sorted_roots: Vec<_> = root_namespaces.keys().collect();
                sorted_roots.sort();

                let mut root_aliases = Vec::with_capacity(sorted_roots.len());

                for (i, root_name) in sorted_roots.iter().enumerate() {
                    if i != 0 {
                        out += "\n";
                    }

                    let modules_in_root = root_namespaces.get(*root_name).unwrap();

                    // Sort modules to process them in order
                    let mut sorted_modules = modules_in_root.clone();
                    sorted_modules.sort();

                    // Build a tree structure: map from parent path to its direct children
                    // This will help us generate namespaces hierarchically
                    let mut path_children: HashMap<String, BTreeSet<String>> = HashMap::new();

                    for module_path in &sorted_modules {
                        let parts: Vec<&str> = module_path.split("::").collect();

                        // For each level, track direct parent-child relationships only
                        for depth in 0..parts.len() {
                            let parent = if depth == 0 {
                                String::new()
                            } else {
                                parts[0..depth].join("::")
                            };
                            let child_name = parts[depth].to_string();

                            path_children.entry(parent).or_default().insert(child_name);
                        }
                    }

                    // Recursive function to generate nested namespaces
                    fn write_namespace(
                        out: &mut String,
                        current_path: &str,
                        depth: usize,
                        path_children: &HashMap<String, BTreeSet<String>>,
                        module_types: &mut HashMap<String, Vec<NamedDataType>>,
                        ts: &Typescript,
                        types: &TypeCollection,
                    ) -> Result<(), Error> {
                        let indent = "    ".repeat(depth);

                        // Get types for this exact path
                        let has_types =
                            if let Some(types_in_module) = module_types.get_mut(current_path) {
                                types_in_module.sort_by(|a, b| {
                                    a.name()
                                        .cmp(b.name())
                                        .then(a.module_path().cmp(b.module_path()))
                                        .then(a.location().cmp(&b.location()))
                                });

                                for ndt in types_in_module {
                                    *out += &indent;
                                    *out += &primitives::export(ts, types, ndt)?;
                                    *out += "\n";
                                }
                                true
                            } else {
                                false
                            };

                        // Get child namespace names
                        if let Some(child_names) = path_children.get(current_path) {
                            for (i, child_name) in child_names.iter().enumerate() {
                                // Add blank line between siblings or after types
                                if i > 0 || has_types {
                                    *out += "\n";
                                }

                                *out += &indent;
                                *out += &format!("export namespace {child_name} {{\n");

                                // Build the full path for the child
                                let child_path = if current_path.is_empty() {
                                    child_name.clone()
                                } else {
                                    format!("{}::{}", current_path, child_name)
                                };

                                write_namespace(
                                    out,
                                    &child_path,
                                    depth + 1,
                                    path_children,
                                    module_types,
                                    ts,
                                    types,
                                )?;

                                *out += &indent;
                                *out += "}\n";
                            }
                        }

                        Ok(())
                    }

                    // Start with the root namespace
                    out += &format!("export namespace {root_name} {{\n");
                    write_namespace(
                        &mut out,
                        root_name,
                        1,
                        &path_children,
                        &mut module_types,
                        self,
                        types,
                    )?;
                    out += "}\n";

                    if !root_name.is_empty() {
                        root_aliases.push(format!(
                            "export import {} = {};\n",
                            root_alias_ident(root_name),
                            root_name
                        ));
                    }
                }

                if !root_aliases.is_empty() {
                    out += "\n";
                    for alias in root_aliases {
                        out += &alias;
                    }
                }

                Ok(out)
            }
            // You can't `inline` while using `Files`.
            Layout::Files => Err(Error::UnableToExport),
            Layout::FlatFile | Layout::ModulePrefixedName => {
                if self.layout == Layout::FlatFile {
                    let mut map = HashMap::with_capacity(types.len());
                    for dt in types.into_unsorted_iter() {
                        if let Some(existing_dt) = map.insert(dt.name().clone(), dt)
                            && existing_dt != dt
                        {
                            return Err(Error::DuplicateTypeName {
                                types: (dt.location(), existing_dt.location()),
                                name: dt.name().clone(),
                            });
                        }
                    }
                }

                self.export_internal(types.into_sorted_iter(), None, types, true)
            }
        }
    }

    fn export_internal(
        &self,
        ndts: impl Iterator<Item = NamedDataType>,
        references: Option<ImportMap>,
        types: &TypeCollection,
        include_runtime: bool,
    ) -> Result<String, Error> {
        let mut out = self.header.to_string();
        if !out.is_empty() {
            out.push('\n');
        }
        out += &self.framework_prelude;
        out.push('\n');
        if include_runtime {
            out.push_str(&self.framework_runtime);
            out.push('\n');
        }

        if self.jsdoc {
            out += "\n/**";
        }

        for (src, items) in references.iter().flatten() {
            if self.jsdoc {
                out += "\n\t* @import";
            } else {
                out += "\nimport type";
            }

            out += " { ";
            for (i, (src, alias)) in items.iter().enumerate() {
                if i != 0 {
                    out += ", ";
                }
                out += src;
                if alias != src {
                    out += " as ";
                    out += alias;
                }
            }

            out += " } from \"";
            out += src;
            out += "\";";
        }

        if self.jsdoc {
            out += "\n\t*/";
        }

        out.push_str("\n\n");

        for (i, ndt) in ndts.enumerate() {
            if i != 0 {
                out += "\n";
            }

            if self.jsdoc {
                out += &primitives::typedef_internal(self, types, &ndt)?;
            } else {
                out += &primitives::export(self, types, &ndt)?;
            }
        }

        Ok(out)
    }

    /// Export the types to a specific file/folder.
    ///
    /// When configured when `format` is `Format::Files`, you must provide a directory path.
    /// Otherwise, you must provide the path of a single file.
    ///
    pub fn export_to(&self, path: impl AsRef<Path>, types: &TypeCollection) -> Result<(), Error> {
        let path = path.as_ref();

        if self.layout == Layout::Files {
            if self.serde {
                specta_serde::validate(types)?;
            }

            std::fs::create_dir_all(path)?;

            let mut files = HashMap::<PathBuf, Vec<NamedDataType>>::new();

            for ndt in types.into_sorted_iter() {
                let mut path = PathBuf::from(path);
                for m in ndt.module_path().split("::") {
                    path = path.join(m);
                }
                path.set_extension(if self.jsdoc { "js" } else { "ts" });
                files.entry(path).or_default().push(ndt);
            }

            let mut used_paths = files.keys().cloned().collect::<HashSet<_>>();

            for (path, ndts) in files {
                if let Some(parent) = path.parent() {
                    std::fs::create_dir_all(parent)?;
                }

                let mut references = ImportMap::default();
                for ndt in ndts.iter() {
                    crawl_for_imports(ndt.ty(), types, &mut references);
                }

                std::fs::write(
                    &path,
                    self.export_internal(ndts.into_iter(), Some(references), types, false)?,
                )?;
            }

            if !self.framework_runtime.is_empty() {
                // TODO: Does this risk conflicting with an `index.rs` module???
                let p = path.join("index.ts");
                let mut content = self.framework_prelude.to_string();
                content.push('\n');
                content.push_str(&self.framework_runtime);
                content.push('\n');
                std::fs::write(&p, content)?;

                // This is to ensure `remove_unused_ts_files` doesn't remove it
                used_paths.insert(p);
            }

            if path.exists() && path.is_dir() {
                fn remove_unused_ts_files(
                    dir: &Path,
                    used_paths: &HashSet<PathBuf>,
                ) -> std::io::Result<()> {
                    for entry in std::fs::read_dir(dir)? {
                        let entry = entry?;
                        let entry_path = entry.path();

                        if entry_path.is_dir() {
                            remove_unused_ts_files(&entry_path, used_paths)?;

                            // Remove empty directories
                            if std::fs::read_dir(&entry_path)?.next().is_none() {
                                std::fs::remove_dir(&entry_path)?;
                            }
                        } else if matches!(
                            entry_path.extension().and_then(|ext| ext.to_str()),
                            Some("ts" | "js")
                        ) && !used_paths.contains(&entry_path)
                        {
                            std::fs::remove_file(&entry_path)?;
                        }
                    }
                    Ok(())
                }

                let _ = remove_unused_ts_files(path, &used_paths);
            }
        } else {
            if let Some(parent) = path.parent() {
                std::fs::create_dir_all(parent)?;
            }

            std::fs::write(path, self.export(types)?)?;
        }

        Ok(())
    }
}

type ImportMap = BTreeMap<String, BTreeSet<(Cow<'static, str>, String)>>;

/// Scan for references in a `DataType` chain and collate the required cross-file imports.
fn crawl_for_imports(dt: &DataType, types: &TypeCollection, imports: &mut ImportMap) {
    fn crawl_references_fields(fields: &Fields, types: &TypeCollection, imports: &mut ImportMap) {
        match fields {
            Fields::Unit => {}
            Fields::Unnamed(fields) => {
                for field in fields.fields() {
                    if let Some(ty) = field.ty() {
                        crawl_for_imports(ty, types, imports);
                    }
                }
            }
            Fields::Named(fields) => {
                for (_, field) in fields.fields() {
                    if let Some(ty) = field.ty() {
                        crawl_for_imports(ty, types, imports);
                    }
                }
            }
        }
    }

    match dt {
        DataType::Primitive(..) => {}
        DataType::List(list) => {
            crawl_for_imports(list.ty(), types, imports);
        }
        DataType::Map(map) => {
            crawl_for_imports(map.key_ty(), types, imports);
            crawl_for_imports(map.value_ty(), types, imports);
        }
        DataType::Nullable(dt) => {
            crawl_for_imports(dt, types, imports);
        }
        DataType::Struct(s) => {
            crawl_references_fields(s.fields(), types, imports);
        }
        DataType::Enum(e) => {
            for (_, variant) in e.variants() {
                crawl_references_fields(variant.fields(), types, imports);
            }
        }
        DataType::Tuple(tuple) => {
            for field in tuple.elements() {
                crawl_for_imports(field, types, imports);
            }
        }
        DataType::Reference(r) => {
            if let Some(ndt) = r.get(types) {
                let mut path = "./".to_string();

                let depth = ndt.module_path().split("::").count();
                for _ in 2..depth {
                    path.push_str("../");
                }

                imports
                    .entry(path)
                    .or_default()
                    .insert((ndt.name().clone(), ndt.module_path().replace("::", "_")));
            }
        }
        DataType::Generic(_) => {}
    }
}

pub(crate) fn root_alias_ident(root: &str) -> String {
    let mut alias = String::from("$specta$root$");
    for ch in root.chars() {
        if ch == '_' || ch.is_ascii_alphanumeric() {
            alias.push(ch);
        } else {
            alias.push('_');
        }
    }
    alias.push('$');
    alias
}

#[cfg(test)]
mod tests {
    use super::*;
    use specta::{Type, TypeCollection};

    #[derive(Type)]
    pub struct RootType {
        data: String,
    }

    #[derive(Type)]
    pub struct MainType {
        nested: dev::another::NestedType,
        root: RootType,
    }

    mod dev {
        use super::*;

        pub mod another {
            use super::*;

            #[derive(Type)]
            pub struct NestedType {
                value: String,
            }

            pub mod deeply {
                use super::*;

                #[derive(Type)]
                pub struct DeeplyNestedType {
                    inner: NestedType,
                }
            }
        }
    }

    #[test]
    fn test_nested_namespaces_generation() {
        let types = TypeCollection::default()
            .register::<RootType>()
            .register::<MainType>()
            .register::<dev::another::NestedType>()
            .register::<dev::another::deeply::DeeplyNestedType>();

        let output = Typescript::new()
            .layout(Layout::Namespaces)
            .export(&types)
            .expect("Should export successfully");

        // The test types are nested under the test module path, so check for the proper nesting
        // Check that we generate nested namespaces instead of flattened ones
        assert!(
            output.contains("export namespace dev {"),
            "Should contain 'export namespace dev {{'"
        );
        assert!(
            output.contains("export namespace another {"),
            "Should contain 'export namespace another {{'"
        );

        // Check that we don't generate flattened namespaces with underscores in root declarations
        assert!(
            !output.contains("export namespace dev_another"),
            "Should not contain flattened namespace names with underscores"
        );

        // Check that type references use proper dot notation
        assert!(
            output.contains(
                "$specta$root$specta_typescript$.typescript.tests.dev.another.NestedType"
            ),
            "Type references should use alias-based dot notation for namespace access"
        );
    }

    #[test]
    fn test_module_prefixed_name_still_uses_underscores() {
        let types = TypeCollection::default()
            .register::<RootType>()
            .register::<MainType>()
            .register::<dev::another::NestedType>();

        let output = Typescript::new()
            .layout(Layout::ModulePrefixedName)
            .export(&types)
            .expect("Should export successfully");

        // ModulePrefixedName should still use underscores as before
        assert!(
            output.contains("dev_another_NestedType"),
            "ModulePrefixedName should still use underscores"
        );
    }
}
