use std::fs::read_to_string;

use specta::{
    Type, TypeCollection,
    datatype::{DataType, NamedDataTypeBuilder, Primitive},
};
use specta_typescript::Layout;

#[derive(Type)]
pub struct Testing {
    a: testing::Testing,
}

#[derive(Type)]
pub struct Another {
    bruh: String,
}

#[derive(Type)]
pub struct MoreType {
    u: String,
}

mod testing {
    use super::*;

    #[derive(Type)]
    pub struct Testing {
        b: testing2::Testing,
    }

    mod testing2 {
        use super::*;

        #[derive(Type)]
        pub struct Testing {
            c: String,
        }
    }
}

#[test]
fn test_formats_with_duplicate_typename() {
    let types = TypeCollection::default()
        .register::<Testing>()
        .register::<Another>()
        .register::<MoreType>();

    assert_eq!(
        specta_typescript::Typescript::new()
            .export(&types)
            .map_err(|e| e
                .to_string()
                .starts_with("Detected multiple types with the same name")),
        Err(true)
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .layout(Layout::FlatFile)
            .export(&types)
            .map_err(|e| e
                .to_string()
                .starts_with("Detected multiple types with the same name")),
        Err(true)
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .layout(Layout::ModulePrefixedName)
            .export(&types)
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type integration_tests_formats_Another = { bruh: string };\n\nexport type integration_tests_formats_MoreType = { u: string };\n\nexport type integration_tests_formats_Testing = { a: integration_tests_formats_testing_Testing };\n\nexport type integration_tests_formats_testing_testing2_Testing = { c: string };\n\nexport type integration_tests_formats_testing_Testing = { b: integration_tests_formats_testing_testing2_Testing };".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .layout(Layout::Namespaces)
            .export(&types)
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport namespace integration_tests {\n    export namespace formats {\n        export type Another = { bruh: string };\n\n        export type MoreType = { u: string };\n\n        export type Testing = { a: $specta$root$integration_tests$.formats.testing.Testing };\n\n        export namespace testing {\n            export type Testing = { b: $specta$root$integration_tests$.formats.testing.testing2.Testing };\n\n            export namespace testing2 {\n                export type Testing = { c: string };\n\n            }\n        }\n    }\n}\n\nexport import $specta$root$integration_tests$ = integration_tests;\n".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .layout(Layout::Files)
            .export(&types)
            .map_err(|e| e.to_string()),
        Err("Unable to export type\n".into())
    );

    let _handle = DeleteOnDrop("_test_types");

    specta_typescript::Typescript::new()
        .layout(Layout::Files)
        .export_to("./_test_types", &types)
        .unwrap();

    assert_eq!(
        read_to_string("_test_types/integration_tests/formats.ts").map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\nimport { Testing as integration_tests_formats_testing_Testing } from \"./../integration_tests/formats/testing\";\n\nexport type Another = { bruh: string };\n\nexport type MoreType = { u: string };\n\nexport type Testing = { a: integration_tests_formats_testing_Testing };".into())
    );

    assert_eq!(
        read_to_string("_test_types/integration_tests/formats/testing.ts")
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\nimport { Testing as integration_tests_formats_testing_testing2_Testing } from \"./../../integration_tests/formats/testing/testing2\";\n\nexport type Testing = { b: integration_tests_formats_testing_testing2_Testing };".into())
    );

    assert_eq!(
        read_to_string("_test_types/integration_tests/formats/testing/testing2.ts")
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type Testing = { c: string };".into())
    );
}

#[test]
fn test_formats_without_duplicate_typename() {
    let types = TypeCollection::default()
        .register::<Another>()
        .register::<MoreType>();

    assert_eq!(
        specta_typescript::Typescript::new()
            .export(&types)
            .map_err(|e| e
                .to_string()
                .starts_with("Detected multiple types with the same name")),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type Another = { bruh: string };\n\nexport type MoreType = { u: string };".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .layout(Layout::FlatFile)
            .export(&types)
            .map_err(|e| e
                .to_string()
                .starts_with("Detected multiple types with the same name")),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type Another = { bruh: string };\n\nexport type MoreType = { u: string };".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .layout(Layout::ModulePrefixedName)
            .export(&types)
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type integration_tests_formats_Another = { bruh: string };\n\nexport type integration_tests_formats_MoreType = { u: string };".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .layout(Layout::Namespaces)
            .export(&types)
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport namespace integration_tests {\n    export namespace formats {\n        export type Another = { bruh: string };\n\n        export type MoreType = { u: string };\n\n    }\n}".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .layout(Layout::Files)
            .export(&types)
            .map_err(|e| e.to_string()),
        Err("Unable to export type\n".into())
    );
}

#[test]
fn test_empty_module_path() {
    let mut types = TypeCollection::default();

    let ndt = NamedDataTypeBuilder::new(
        "testing",
        Default::default(),
        DataType::Primitive(Primitive::i8),
    )
    .build(&mut types);

    // types
    //     .create()
    //     .unwrap();

    // types
    //     .create(
    //         NamedDataTypeBuilder::new(
    //             "testing2",
    //             Default::default(),
    //             DataType::Primitive(Primitive::i8),
    //         )
    //         .module_path("testing"),
    //     )
    //     .unwrap();

    assert_eq!(
        specta_typescript::Typescript::new()
            .layout(Layout::FlatFile)
            .export(&types)
            .map_err(|e| e
                .to_string()
                .starts_with("Detected multiple types with the same name")),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type testing = number;".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .layout(Layout::ModulePrefixedName)
            .export(&types)
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type virtual_testing = number;".into())
    );

    assert_eq!(
        specta_typescript::Typescript::new()
            .layout(Layout::Namespaces)
            .export(&types)
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport namespace virtual {\n    export type testing = number;\n\n}".into())
    );

    let _handle = DeleteOnDrop("_unnamed_test");

    specta_typescript::Typescript::new()
        .layout(Layout::Files)
        .export_to("./_unnamed_test", &types)
        .unwrap();

    assert_eq!(
        read_to_string("_unnamed_test/virtual.ts")
            .map_err(|e| e.to_string()),
        Ok("// This file has been generated by Specta. DO NOT EDIT.\n\nexport type testing = number;".into())
    );
}

struct DeleteOnDrop(pub &'static str);
impl Drop for DeleteOnDrop {
    fn drop(&mut self) {
        std::fs::remove_dir_all(self.0).ok();
    }
}
