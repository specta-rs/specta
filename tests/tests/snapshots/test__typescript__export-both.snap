---
source: tests2/tests/typescript.rs
expression: "dts.iter().filter_map(|(s, ty)| match ty\n{\n    DataType::Reference(r) => r.get(&types).cloned().map(|ty| (s, ty)), _ =>\n    None,\n}).map(|(s, ty)|\nprimitives::export(&ts, &types,\n&ty).map(|ty| format!(\"{s}: {ty}\"))).collect::<Result<Vec<_>,\n_>>().unwrap().join(\"\\n\")"
---
Unit1: export type Unit1 = null;

Unit2: export type Unit2 = Record<string, never>;

Unit3: export type Unit3 = [];

Unit4: export type Unit4 = null;

Unit5: export type Unit5 = "A";

Unit6: export type Unit6 = { A: [] };

Unit7: export type Unit7 = { A: Record<string, never> };

SimpleStruct: export type SimpleStruct = { 
		a: number,
		b: string,
		c: [number, string, number],
		d: string[],
		e: string | null,
	};

TupleStruct1: export type TupleStruct1 = number;

TupleStruct3: export type TupleStruct3 = [number, boolean, string];

TestEnum: export type TestEnum = "Unit" | { Single: number } | { Multiple: [number, number] } | { Struct: { a: number } };

RefStruct: export type RefStruct = TestEnum;

InlinerStruct: export type InlinerStruct = { 
		inline_this: InlineStruct,
		dont_inline_this: RefStruct,
	};

GenericStruct<i32>: export type GenericStruct<T> = { 
		arg: T,
	};

GenericStruct<String>: export type GenericStruct<T> = { 
		arg: T,
	};

FlattenEnumStruct: export type FlattenEnumStruct = (FlattenEnum) & { 
		outer: string,
	};

OverridenStruct: export type OverridenStruct = { 
		overriden_field: string,
	};

HasGenericAlias: export type HasGenericAlias = { [key in number]: string };

SkipVariant: export type SkipVariant = { A: string };

SkipVariant2: export type SkipVariant2 = string;

SkipVariant3: export type SkipVariant3 = { A: { a: string } };

EnumMacroAttributes: export type EnumMacroAttributes = { A: string } | { B: number } | { C: number } | { D: { a: string; b: number } };

InlineEnumField: export type InlineEnumField = { A: PlaceholderInnerField };

InlineOptionalType: export type InlineOptionalType = { 
		optional_field: PlaceholderInnerField | null,
	};

Rename: export type Rename = "OneWord" | "TwoWords";

TransparentType: export type TransparentType = TransparentTypeInner;

TransparentType2: export type TransparentType2 = null;

TransparentTypeWithOverride: export type TransparentTypeWithOverride = string;

EnumReferenceRecordKey: export type EnumReferenceRecordKey = { 
		a: Partial<{ [key in BasicEnum]: number }>,
	};

FlattenOnNestedEnum: export type FlattenOnNestedEnum = (NestedEnum) & { 
		id: string,
	};

MyEmptyInput: export type MyEmptyInput = Record<string, never>;

ExtraBracketsInTupleVariant: export type ExtraBracketsInTupleVariant = { A: string };

ExtraBracketsInUnnamedStruct: export type ExtraBracketsInUnnamedStruct = string;

InlineTuple: export type InlineTuple = { 
		demo: [string, boolean],
	};

InlineTuple2: export type InlineTuple2 = { 
		demo: [InlineTuple, boolean],
	};

SkippedFieldWithinVariant: export type SkippedFieldWithinVariant = never | string;

KebabCase: export type KebabCase = { 
		test_ing: string,
	};

Issue281<'_>: export type Issue281 = { 
		default_unity_arguments: string[],
	};

RenameWithWeirdCharsField: export type RenameWithWeirdCharsField = { 
		odata_context: string,
	};

RenameWithWeirdCharsVariant: export type RenameWithWeirdCharsVariant = { A: string };

Issue374: /**
 * https://github.com/specta-rs/specta/issues/374
 */
export type Issue374 = { 
		foo: boolean,
		bar: boolean,
	};

type_type::Type: export type Type = never;

ActualType: export type ActualType = { 
		a: GenericType<string>,
	};

SpectaTypeOverride: export type SpectaTypeOverride = { 
		string_ident: string,
		u32_ident: number,
		path: string,
	};

InvalidToValidType: export type InvalidToValidType = { 
		cause: null | null,
	};

TupleStruct: export type TupleStruct = string;

TupleStructWithRep: export type TupleStructWithRep = string;

GenericTupleStruct<String>: export type GenericTupleStruct<T> = T;

BracedStruct: export type BracedStruct = string;

Recursive: export type Recursive = { 
		demo: Recursive,
	};

RecursiveMapValue: export type RecursiveMapValue = { 
		demo: { [key in string]: RecursiveMapValue },
	};

RecursiveTransparent: export type RecursiveTransparent = RecursiveInline;

RecursiveInEnum: export type RecursiveInEnum = { A: (RecursiveInEnum) };

NonOptional: export type NonOptional = string | null;

OptionalOnNamedField: export type OptionalOnNamedField = string | null;

OptionalOnTransparentNamedField: export type OptionalOnTransparentNamedField = { 
		b: string | null,
	};

OptionalInEnum: export type OptionalInEnum = { A: string | null } | { B: { a: string | null } } | { C: { a?: string | null } };

Regular: export type Regular = { [key in string]: null };

MacroStruct: export type MacroStruct = string;

MacroStruct2: export type MacroStruct2 = { 
		demo: string,
	};

MacroEnum: export type MacroEnum = { Demo: string } | { Demo2: { demo2: string } };

DeprecatedType: /**
 * @deprecated
 */
export type DeprecatedType = { 
		a: number,
	};

DeprecatedTypeWithMsg: /**
 * @deprecated Look at you big man using a deprecation message
 */
export type DeprecatedTypeWithMsg = { 
		a: number,
	};

DeprecatedTypeWithMsg2: /**
 * @deprecated Look at you big man using a deprecation message
 */
export type DeprecatedTypeWithMsg2 = { 
		a: number,
	};

DeprecatedFields: export type DeprecatedFields = { 
		a: number,
		
	/**
 * @deprecated
 */
b: string,
		
	/**
 * @deprecated This field is cringe!
 */
c: string,
		
	/**
 * @deprecated This field is cringe!
 */
d: string,
	};

DeprecatedTupleVariant: export type DeprecatedTupleVariant = [
	/**
 * @deprecated
 */
string, 
	/**
 * @deprecated Nope
 */
string, 
	/**
 * @deprecated Nope
 */
number];

DeprecatedEnumVariants: export type DeprecatedEnumVariants = 
	/**
 * @deprecated
 */
"A" | 
	/**
 * @deprecated Nope
 */
"B" | 
	/**
 * @deprecated Nope
 */
"C";

CommentedStruct: /**
 * Some triple-slash comment
 * Some more triple-slash comment
 */
export type CommentedStruct = { 
		
	/**
 * Some triple-slash comment
 * Some more triple-slash comment
 */
a: number,
	};

CommentedEnum: /**
 * Some triple-slash comment
 * Some more triple-slash comment
 */
export type CommentedEnum = 
	/**
 * Some triple-slash comment
 * Some more triple-slash comment
 */
{ A: number } | 
	/**
 * Some triple-slash comment
 * Some more triple-slash comment
 */
{ B: { 
	/**
 * Some triple-slash comment
 * Some more triple-slash comment
 */
a: number } };

SingleLineComment: /**
 * Some single-line comment
 */
export type SingleLineComment = 
	/**
 * Some single-line comment
 */
{ A: number } | 
	/**
 * Some single-line comment
 */
{ B: { 
	/**
 * Some single-line comment
 */
a: number } };

NonGeneric: export type Demo<A, B> = { 
		a: A,
		b: B,
	};

HalfGenericA<u8>: export type Demo<A, B> = { 
		a: A,
		b: B,
	};

HalfGenericB<bool>: export type Demo<A, B> = { 
		a: A,
		b: B,
	};

FullGeneric<u8, bool>: export type Demo<A, B> = { 
		a: A,
		b: B,
	};

Another<bool>: export type Demo<A, B> = { 
		a: A,
		b: B,
	};

AGenericStruct<u32>: export type AGenericStruct<T> = { 
		field: Demo<T, boolean>,
	};

A: export type A = { 
		a: B,
		b: B,
		c: B,
		d: D,
		e: GenericFlattened<number>,
	};

DoubleFlattened: export type DoubleFlattened = { 
		a: ToBeFlattened,
		b: ToBeFlattened,
	};

FlattenedInner: export type FlattenedInner = { 
		c: Inner,
	};

BoxFlattened: export type BoxFlattened = { 
		b: BoxedInner,
	};

BoxInline: export type BoxInline = { 
		c: BoxedInner,
	};

First: export type First = { 
		a: string,
	};

Second: export type Second = { 
		a: number,
	};

Third: export type Third = (First) & { 
		b: { [key in string]: string },
		c: First,
	};

Fourth: export type Fourth = { 
		a: First,
		b: First,
	};

Fifth: export type Fifth = { 
		a: First,
		b: First,
	};

Sixth: export type Sixth = { 
		a: First,
		b: First,
	};

Seventh: export type Seventh = { 
		a: First,
		b: Second,
	};

Eight: export type Eight = { A: string } | "B";

Tenth: export type Tenth = string | "B" | First;

MyEnumTagged: export type MyEnumTagged = (First);

MyEnumExternal: export type MyEnumExternal = { Variant: (First) };

MyEnumAdjacent: export type MyEnumAdjacent = (First);

MyEnumUntagged: export type MyEnumUntagged = (First);
