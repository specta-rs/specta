---
source: tests/tests/typescript.rs
expression: "dts.iter().filter_map(|(s, ty)| match ty\n{\n    DataType::Reference(Reference::Named(r)) =>\n    r.get(&types).cloned().map(|ty| (s, ty)), _ => None,\n}).map(|(s, ty)|\nprimitives::export(&ts, &types,\n&ty).map(|ty| format!(\"{s}: {ty}\"))).collect::<Result<Vec<_>,\n_>>().unwrap().join(\"\\n\")"
---
Unit1: export type Unit1 = null;

Unit2: export type Unit2 = Record<string, never>;

Unit3: export type Unit3 = [];

Unit4: export type Unit4 = null;

Unit5: export type Unit5 = "A";

Unit6: export type Unit6 = { A: [] };

Unit7: export type Unit7 = { A: Record<string, never> };

SimpleStruct: export type SimpleStruct = {
	a: number,
	b: string,
	c: [number, string, number],
	d: string[],
	e: string | null,
};

TupleStruct1: export type TupleStruct1 = number;

TupleStruct3: export type TupleStruct3 = [number, boolean, string];

TestEnum: export type TestEnum = "Unit" | { Single: number } | { Multiple: [number, number] } | { Struct: { a: number } };

RefStruct: export type RefStruct = TestEnum;

InlinerStruct: export type InlinerStruct = {
	inline_this: {
		ref_struct: SimpleStruct,
		val: number,
	},
	dont_inline_this: RefStruct,
};

GenericStruct<i32>: export type GenericStruct<T> = {
	arg: T,
};

GenericStruct<String>: export type GenericStruct<T> = {
	arg: T,
};

FlattenEnumStruct: export type FlattenEnumStruct = (FlattenEnum) & {
	outer: string,
};

OverridenStruct: export type OverridenStruct = {
	overriden_field: string,
};

HasGenericAlias: export type HasGenericAlias = { [key in number]: string };

EnumMacroAttributes: export type EnumMacroAttributes = { A: string } | { B: number } | { C: number } | { D: { a: string; b: number } };

InlineEnumField: export type InlineEnumField = { A: PlaceholderInnerField };

InlineOptionalType: export type InlineOptionalType = {
	optional_field: {
		a: string,
	} | null,
};

Rename: export type Rename = "OneWord" | "TwoWords";

TransparentType: export type TransparentType = TransparentTypeInner;

TransparentType2: export type TransparentType2 = null;

TransparentTypeWithOverride: export type TransparentTypeWithOverride = string;

EnumReferenceRecordKey: export type EnumReferenceRecordKey = {
	a: Partial<{ [key in BasicEnum]: number }>,
};

FlattenOnNestedEnum: export type FlattenOnNestedEnum = (NestedEnum) & {
	id: string,
};

MyEmptyInput: export type MyEmptyInput = Record<string, never>;

ExtraBracketsInTupleVariant: export type ExtraBracketsInTupleVariant = { A: string };

ExtraBracketsInUnnamedStruct: export type ExtraBracketsInUnnamedStruct = string;

InlineTuple: export type InlineTuple = {
	demo: [string, boolean],
};

InlineTuple2: export type InlineTuple2 = {
	demo: [{
		demo: [string, boolean],
	}, boolean],
};

SkippedFieldWithinVariant: export type SkippedFieldWithinVariant = never | string;

KebabCase: export type KebabCase = {
	test_ing: string,
};

Issue281<'_>: export type Issue281 = {
	default_unity_arguments: string[],
};

RenameWithWeirdCharsField: export type RenameWithWeirdCharsField = {
	odata_context: string,
};

RenameWithWeirdCharsVariant: export type RenameWithWeirdCharsVariant = { A: string };

Issue374: /**
 *  https://github.com/specta-rs/specta/issues/374
 */
export type Issue374 = {
	foo: boolean,
	bar: boolean,
};

type_type::Type: export type Type = never;

ActualType: export type ActualType = {
	a: GenericType<string>,
};

SpectaTypeOverride: export type SpectaTypeOverride = {
	string_ident: string,
	u32_ident: number,
	path: string,
};

InvalidToValidType: export type InvalidToValidType = {
	cause: null | null,
};

TupleStruct: export type TupleStruct = string;

TupleStructWithRep: export type TupleStructWithRep = string;

GenericTupleStruct<String>: export type GenericTupleStruct<T> = T;

BracedStruct: export type BracedStruct = string;

StructRenameAllUppercase: export type StructRenameAllUppercase = {
	a: number,
	b: number,
};

RenameSerdeSpecialChar: export type RenameSerdeSpecialChar = {
	b: number,
};

EnumRenameAllUppercase: export type EnumRenameAllUppercase = "HelloWorld" | "VariantB" | "TestingWords";

Recursive: export type Recursive = {
	demo: Recursive,
};

RecursiveMapValue: export type RecursiveMapValue = {
	demo: { [key in string]: RecursiveMapValue },
};

RecursiveTransparent: export type RecursiveTransparent = RecursiveInline;

RecursiveInEnum: export type RecursiveInEnum = { A: (RecursiveInEnum) };

NonOptional: export type NonOptional = string | null;

OptionalOnNamedField: export type OptionalOnNamedField = string | null;

OptionalOnTransparentNamedField: export type OptionalOnTransparentNamedField = {
	b: string | null,
};

OptionalInEnum: export type OptionalInEnum = { A: string | null } | { B: { a: string | null } } | { C: { a?: string | null } };

Optional: export type Optional = {
	a: number | null,
	b?: number | null,
	c: string | null,
	d: boolean,
};

UntaggedVariants: export type UntaggedVariants = string | number | { id: string } | [string, boolean];

UntaggedVariantsWithoutValue: export type UntaggedVariantsWithoutValue = string | [number, string] | number;

Regular: export type Regular = { [key in string]: null };

MacroStruct: export type MacroStruct = string;

MacroStruct2: export type MacroStruct2 = {
	demo: string,
};

MacroEnum: export type MacroEnum = { Demo: string } | { Demo2: { demo2: string } };

DeprecatedType: /**
 * @deprecated
 */
export type DeprecatedType = {
	a: number,
};

DeprecatedTypeWithMsg: /**
 * @deprecated Look at you big man using a deprecation message
 */
export type DeprecatedTypeWithMsg = {
	a: number,
};

DeprecatedTypeWithMsg2: /**
 * @deprecated Look at you big man using a deprecation message
 */
export type DeprecatedTypeWithMsg2 = {
	a: number,
};

DeprecatedFields: export type DeprecatedFields = {
	a: number,
	/**
	 * @deprecated
	 */
	b: string,
	/**
	 * @deprecated This field is cringe!
	 */
	c: string,
	/**
	 * @deprecated This field is cringe!
	 */
	d: string,
};

DeprecatedTupleVariant: export type DeprecatedTupleVariant = [
/**
 * @deprecated
 */
string, 
/**
 * @deprecated Nope
 */
string, 
/**
 * @deprecated Nope
 */
number];

DeprecatedEnumVariants: export type DeprecatedEnumVariants = 
/**
 * @deprecated
 */
"A" | 
/**
 * @deprecated Nope
 */
"B" | 
/**
 * @deprecated Nope
 */
"C";

CommentedStruct: /**
 *  Some triple-slash comment
 *  Some more triple-slash comment
 */
export type CommentedStruct = {
	/**
	 *  Some triple-slash comment
	 *  Some more triple-slash comment
	 */
	a: number,
};

CommentedEnum: /**
 *  Some triple-slash comment
 *  Some more triple-slash comment
 */
export type CommentedEnum = 
/**
 *  Some triple-slash comment
 *  Some more triple-slash comment
 */
{ A: number } | 
/**
 *  Some triple-slash comment
 *  Some more triple-slash comment
 */
{ B: { 
/**
 *  Some triple-slash comment
 *  Some more triple-slash comment
 */
a: number } };

SingleLineComment: /**
 *  Some single-line comment
 */
export type SingleLineComment = 
/**
 *  Some single-line comment
 */
{ A: number } | 
/**
 *  Some single-line comment
 */
{ B: { 
/**
 *  Some single-line comment
 */
a: number } };

NonGeneric: export type Demo<A, B> = {
	a: A,
	b: B,
};

HalfGenericA<u8>: export type Demo<A, B> = {
	a: A,
	b: B,
};

HalfGenericB<bool>: export type Demo<A, B> = {
	a: A,
	b: B,
};

FullGeneric<u8, bool>: export type Demo<A, B> = {
	a: A,
	b: B,
};

Another<bool>: export type Demo<A, B> = {
	a: A,
	b: B,
};

AGenericStruct<u32>: export type AGenericStruct<T> = {
	field: Demo<T, boolean>,
};

A: export type A = {
	a: B,
	b: {
		b: number,
	},
	c: B,
	d: {
		flattened: number,
	},
	e: {
		generic_flattened: number,
	},
};

DoubleFlattened: export type DoubleFlattened = {
	a: ToBeFlattened,
	b: ToBeFlattened,
};

FlattenedInner: export type FlattenedInner = {
	c: Inner,
};

BoxFlattened: export type BoxFlattened = {
	b: BoxedInner,
};

BoxInline: export type BoxInline = {
	c: {
		a: number,
	},
};

First: export type First = {
	a: string,
};

Second: export type Second = {
	a: number,
};

Third: export type Third = (First) & {
	b: { [key in string]: string },
	c: First,
};

Fourth: export type Fourth = {
	a: First,
	b: {
		a: string,
	},
};

TagOnStructWithInline: export type TagOnStructWithInline = {
	a: First,
	b: {
		a: string,
	},
};

Sixth: export type Sixth = {
	a: First,
	b: First,
};

Seventh: export type Seventh = {
	a: First,
	b: Second,
};

Eight: export type Eight = { A: string } | "B";

Tenth: export type Tenth = string | "B" | First;

MyEnumTagged: export type MyEnumTagged = (First);

MyEnumExternal: export type MyEnumExternal = { Variant: (First) };

MyEnumAdjacent: export type MyEnumAdjacent = (First);

MyEnumUntagged: export type MyEnumUntagged = (First);

EmptyStruct: export type EmptyStruct = Record<string, never>;

EmptyStructWithTag: export type EmptyStructWithTag = Record<string, never>;

AdjacentlyTagged: export type AdjacentlyTagged = A | { id: string; method: string } | string;

LoadProjectEvent: export type LoadProjectEvent = { project_name: string } | { project_name: string; status: string; progress: number } | { project_name: string };

ExternallyTagged: export type ExternallyTagged = "A" | { B: { id: string; method: string } } | { C: string };

InternallyTaggedB: export type InternallyTaggedB = string;

InternallyTaggedC: export type InternallyTaggedC = string[];

InternallyTaggedD: export type InternallyTaggedD = { [key in string]: string };

InternallyTaggedE: export type InternallyTaggedE = null;

InternallyTaggedF: export type InternallyTaggedF = InternallyTaggedFInner;

InternallyTaggedG: export type InternallyTaggedG = InternallyTaggedGInner;

InternallyTaggedH: export type InternallyTaggedH = InternallyTaggedHInner;

InternallyTaggedI: export type InternallyTaggedI = InternallyTaggedIInner;

InternallyTaggedL: export type InternallyTaggedL = InternallyTaggedLInner;

InternallyTaggedM: export type InternallyTaggedM = InternallyTaggedMInner;

StructWithAlias: export type StructWithAlias = {
	field: string,
};

StructWithMultipleAliases: export type StructWithMultipleAliases = {
	field: string,
};

StructWithAliasAndRename: export type StructWithAliasAndRename = {
	field: string,
};

EnumWithVariantAlias: export type EnumWithVariantAlias = "Variant" | "Other";

EnumWithMultipleVariantAliases: export type EnumWithMultipleVariantAliases = "Variant" | "Other";

EnumWithVariantAliasAndRename: export type EnumWithVariantAliasAndRename = "Variant" | "Other";

InternallyTaggedWithAlias: export type InternallyTaggedWithAlias = { field: string } | { other: number };

AdjacentlyTaggedWithAlias: export type AdjacentlyTaggedWithAlias = { field: string } | { other: number };

UntaggedWithAlias: export type UntaggedWithAlias = { field: string } | { other: number };

EmptyEnum: export type EmptyEnum = never;

EmptyEnumTagged: export type EmptyEnumTagged = never;

EmptyEnumTaggedWContent: export type EmptyEnumTaggedWContent = never;

EmptyEnumUntagged: export type EmptyEnumUntagged = never;

TaggedEnumOfUnitStruct: export type TaggedEnumOfUnitStruct = UnitStruct;

TaggedEnumOfEmptyBracedStruct: export type TaggedEnumOfEmptyBracedStruct = EmptyBracedStruct;

TaggedEnumOfEmptyTupleStruct: export type TaggedEnumOfEmptyTupleStruct = EmptyTupleStruct;

TaggedEnumOfEmptyTupleBracedStructs: export type TaggedEnumOfEmptyTupleBracedStructs = EmptyBracedStruct;

TaggedStructOfStructWithTuple: export type TaggedStructOfStructWithTuple = TupleStructWithTuple;

SkipOnlyField: export type SkipOnlyField = Record<string, never>;

SkipField: export type SkipField = {
	b: number,
};

SkipOnlyVariantExternallyTagged: export type SkipOnlyVariantExternallyTagged = never;

SkipOnlyVariantInternallyTagged: export type SkipOnlyVariantInternallyTagged = never;

SkipOnlyVariantAdjacentlyTagged: export type SkipOnlyVariantAdjacentlyTagged = never;

SkipOnlyVariantUntagged: export type SkipOnlyVariantUntagged = never;

SkipVariant: export type SkipVariant = { A: string };

SkipUnnamedFieldInVariant: export type SkipUnnamedFieldInVariant = "A" | { B: [number] };

SkipNamedFieldInVariant: export type SkipNamedFieldInVariant = { A: Record<string, never> } | { B: { b: number } };

TransparentWithSkip: export type TransparentWithSkip = null;

TransparentWithSkip2: export type TransparentWithSkip2 = string;

TransparentWithSkip3: export type TransparentWithSkip3 = string;

SkipVariant2: export type SkipVariant2 = string;

SkipVariant3: export type SkipVariant3 = { A: { a: string } };

SkipStructFields: export type SkipStructFields = {
	a: number,
};

SpectaSkipNonTypeField: export type SpectaSkipNonTypeField = {
	a: number,
};

FlattenA: export type FlattenA = {
	a: number,
	b: number,
};

FlattenB: export type FlattenB = (FlattenA) & {
	c: number,
};

FlattenC: export type FlattenC = (FlattenA) & {
	c: number,
};

FlattenD: export type FlattenD = {
	a: FlattenA,
	c: number,
};

FlattenE: export type FlattenE = {
	b: (FlattenA) & {
		c: number,
	},
	d: number,
};

FlattenF: export type FlattenF = {
	b: (FlattenA) & {
		c: number,
	},
	d: number,
};

FlattenG: export type FlattenG = {
	b: FlattenB,
	d: number,
};

TupleNested: export type TupleNested = [number[], [number[], number[]], [number[], number[], number[]]];

Generic1<()>: export type Generic1<T> = {
	value: T,
	values: T[],
};

GenericAutoBound<()>: export type GenericAutoBound<T> = {
	value: T,
	values: T[],
};

GenericAutoBound2<()>: export type GenericAutoBound2<T> = {
	value: T,
	values: T[],
};

Container1: export type Container1 = {
	foo: Generic1<number>,
	bar: Generic1<number>[],
	baz: { [key in string]: Generic1<string> },
};

Generic2<(), String, i32>: export type Generic2<A, B, C> = { A: A } | { B: [B, B, B] } | { C: C[] } | { D: A[][][] } | { E: { a: A; b: B; c: C } } | { X: number[] } | { Y: number } | { Z: number[][] };

GenericNewType1<()>: export type GenericNewType1<T> = T[][];

GenericTuple<()>: export type GenericTuple<T> = [T, T[], T[][]];

GenericStruct2<()>: export type GenericStruct2<T> = {
	a: T,
	b: [T, T],
	c: [T, [T, T]],
	d: [T, T, T],
	e: [([T, T]), ([T, T]), ([T, T])],
	f: T[],
	g: T[][],
	h: ([([T, T]), ([T, T]), ([T, T])])[],
};

InlineGenericNewtype<String>: export type InlineGenericNewtype<T> = T;

InlineGenericNested<String>: export type InlineGenericNested<T> = [T, T[], [T, T], { [key in string]: T }, T | null, "Unit" | { Unnamed: T } | { Named: { value: T } }];

InlineFlattenGenericsG<()>: export type InlineFlattenGenericsG<T> = {
	t: T,
};

InlineFlattenGenerics: export type InlineFlattenGenerics = (InlineFlattenGenericsG<string>) & {
	g: InlineFlattenGenericsG<string>,
	gi: {
		t: string,
	},
};

GenericParameterOrderPreserved: export type GenericParameterOrderPreserved = {
	pair: Pair<number, string>,
};
