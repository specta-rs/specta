---
source: tests/tests/typescript.rs
expression: fs_to_string(&path).unwrap()
---
ts-export-to-namespaces-deserialize (25501 bytes)
────────────────────────────────────────
// This file has been generated by Specta. Do not edit this file manually.

namespace $s$ {

	export namespace test {

		export namespace types {

			export type A = {
				a: $s$.test.types.B,
				b: {
					b: number,
				},
				c: $s$.test.types.B,
				d: {
					flattened: number,
				},
				e: {
					generic_flattened: number,
				},
			};

			export type AGenericStruct<T> = {
				field: $s$.test.types.Demo<T, boolean>,
			};

			export type ActualType = {
				a: $s$.test.types.GenericType<string>,
			};

			export type AdjacentlyTagged = { t: "A" } | { t: "B"; c: {
	id: string,
	method: string,
} } | { t: "C"; c: string };

			export type AdjacentlyTaggedWithAlias = { type: "A"; data: {
	field: string,
} } | { type: "B"; data: {
	other: number,
} };

			export type B = {
				b: number,
			};

			export type BasicEnum = "A" | "B";

			export type BoxFlattened = {
				b: $s$.test.types.BoxedInner,
			};

			export type BoxInline = {
				c: {
					a: number,
				},
			};

			export type BoxedInner = {
				a: number,
			};

			export type BracedStruct = string;

			/**
			 *  Some triple-slash comment
			 *  Some more triple-slash comment
			 */
			export type CommentedEnum = 
			/**
			 *  Some triple-slash comment
			 *  Some more triple-slash comment
			 */
{ A: number } | 
			/**
			 *  Some triple-slash comment
			 *  Some more triple-slash comment
			 */
{ B: { 
			/**
			 *  Some triple-slash comment
			 *  Some more triple-slash comment
			 */
a: number } };

			/**
			 *  Some triple-slash comment
			 *  Some more triple-slash comment
			 */
			export type CommentedStruct = {
				/**
				 *  Some triple-slash comment
				 *  Some more triple-slash comment
				 */
				a: number,
			};

			export type Container1 = {
				foo: $s$.test.types.Generic1<number>,
				bar: $s$.test.types.Generic1<number>[],
				baz: { [key in string]: $s$.test.types.Generic1<string> },
			};

			export type D = {
				flattened: number,
			};

			export type Demo<A, B> = {
				a: A,
				b: B,
			};

			export type DeprecatedEnumVariants = 
			/**
			 * @deprecated
			 */
"A" | 
			/**
			 * @deprecated Nope
			 */
"B" | 
			/**
			 * @deprecated Nope
			 */
"C";

			export type DeprecatedFields = {
				a: number,
				/**
				 * @deprecated
				 */
				b: string,
				/**
				 * @deprecated This field is cringe!
				 */
				c: string,
				/**
				 * @deprecated This field is cringe!
				 */
				d: string,
			};

			export type DeprecatedTupleVariant = [
			/**
			 * @deprecated
			 */
string, 
			/**
			 * @deprecated Nope
			 */
string, 
			/**
			 * @deprecated Nope
			 */
number];

			/**
			 * @deprecated
			 */
			export type DeprecatedType = {
				a: number,
			};

			/**
			 * @deprecated Look at you big man using a deprecation message
			 */
			export type DeprecatedTypeWithMsg = {
				a: number,
			};

			/**
			 * @deprecated Look at you big man using a deprecation message
			 */
			export type DeprecatedTypeWithMsg2 = {
				a: number,
			};

			export type DoubleFlattened = {
				a: $s$.test.types.ToBeFlattened,
				b: $s$.test.types.ToBeFlattened,
			};

			export type Eight = { A: string } | "B";

			export type EmptyBracedStruct = Record<string, never>;

			export type EmptyEnum = never;

			export type EmptyEnumTagged = never;

			export type EmptyEnumTaggedWContent = never;

			export type EmptyEnumUntagged = never;

			export type EmptyStruct = Record<string, never>;

			export type EmptyStructWithTag = {
				a: "EmptyStructWithTag",
			};

			export type EmptyTupleStruct = [];

			export type EnumMacroAttributes = { A: string } | { bbb: number } | { cccc: number } | { D: { a: string; bbbbbb: number } };

			export type EnumReferenceRecordKey = {
				a: Partial<{ [key in $s$.test.types.BasicEnum]: number }>,
			};

			export type EnumRenameAllUppercase = "HELLOWORLD" | "VARIANTB" | "TESTINGWORDS";

			export type EnumWithMultipleVariantAliases = "Variant" | "Other";

			export type EnumWithVariantAlias = "Variant" | "Other";

			export type EnumWithVariantAliasAndRename = "renamed_variant" | "Other";

			export type ExternallyTagged = "A" | { B: { id: string; method: string } } | { C: string };

			export type ExtraBracketsInTupleVariant = { A: string };

			export type ExtraBracketsInUnnamedStruct = string;

			export type First = {
				a: string,
			};

			export type FlattenA = {
				a: number,
				b: number,
			};

			export type FlattenB = ($s$.test.types.FlattenA) & {
				c: number,
			};

			export type FlattenC = ($s$.test.types.FlattenA) & {
				c: number,
			};

			export type FlattenD = {
				a: $s$.test.types.FlattenA,
				c: number,
			};

			export type FlattenE = {
				b: ($s$.test.types.FlattenA) & {
					c: number,
				},
				d: number,
			};

			export type FlattenEnum = { tag: "One" } | { tag: "Two" } | { tag: "Three" };

			export type FlattenEnumStruct = ($s$.test.types.FlattenEnum) & {
				outer: string,
			};

			export type FlattenF = {
				b: ($s$.test.types.FlattenA) & {
					c: number,
				},
				d: number,
			};

			export type FlattenG = {
				b: $s$.test.types.FlattenB,
				d: number,
			};

			export type FlattenOnNestedEnum = ($s$.test.types.NestedEnum) & {
				id: string,
			};

			export type FlattenedInner = {
				c: $s$.test.types.Inner,
			};

			export type Fourth = {
				a: $s$.test.types.First,
				b: {
					a: string,
				},
			};

			export type Generic1<T> = {
				value: T,
				values: T[],
			};

			export type Generic2<A, B, C> = { A: A } | { B: [B, B, B] } | { C: C[] } | { D: A[][][] } | { E: { a: A; b: B; c: C } } | { X: number[] } | { Y: number } | { Z: number[][] };

			export type GenericAutoBound<T> = {
				value: T,
				values: T[],
			};

			export type GenericAutoBound2<T> = {
				value: T,
				values: T[],
			};

			export type GenericFlattened<T> = {
				generic_flattened: T,
			};

			export type GenericNewType1<T> = T[][];

			export type GenericParameterOrderPreserved = {
				pair: $s$.test.types.Pair<number, string>,
			};

			export type GenericStruct<T> = {
				arg: T,
			};

			export type GenericStruct2<T> = {
				a: T,
				b: [T, T],
				c: [T, [T, T]],
				d: [T, T, T],
				e: [([T, T]), ([T, T]), ([T, T])],
				f: T[],
				g: T[][],
				h: ([([T, T]), ([T, T]), ([T, T])])[],
			};

			export type GenericTuple<T> = [T, T[], T[][]];

			export type GenericTupleStruct<T> = T;

			export type GenericType<T> = "Undefined" | T;

			export type HasGenericAlias = { [key in number]: string };

			export type InlineEnumField = { A: {
	a: string,
} };

			export type InlineFlattenGenerics = ($s$.test.types.InlineFlattenGenericsG<string>) & {
				g: $s$.test.types.InlineFlattenGenericsG<string>,
				gi: {
					t: string,
				},
			};

			export type InlineFlattenGenericsG<T> = {
				t: T,
			};

			export type InlineOptionalType = {
				optional_field: {
					a: string,
				} | null,
			};

			export type InlineStruct = {
				ref_struct: $s$.test.types.SimpleStruct,
				val: number,
			};

			export type InlineTuple = {
				demo: [string, boolean],
			};

			export type InlineTuple2 = {
				demo: [{
					demo: [string, boolean],
				}, boolean],
			};

			export type InlinerStruct = {
				inline_this: {
					ref_struct: $s$.test.types.SimpleStruct,
					val: number,
				},
				dont_inline_this: $s$.test.types.RefStruct,
			};

			export type Inner = {
				a: number,
				b: $s$.test.types.FlattenedInner,
			};

			export type InternallyTaggedB = { type: "A" };

			export type InternallyTaggedC = { type: "A" };

			export type InternallyTaggedD = { type: "A" };

			export type InternallyTaggedE = { type: "A" };

			export type InternallyTaggedF = { type: "A" };

			export type InternallyTaggedFInner = null;

			export type InternallyTaggedG = { type: "A" };

			export type InternallyTaggedGInner = string;

			export type InternallyTaggedH = { type: "A" };

			export type InternallyTaggedHInner = null;

			export type InternallyTaggedI = { type: "A" };

			export type InternallyTaggedIInner = string;

			export type InternallyTaggedL = { type: "A" };

			export type InternallyTaggedLInner = { type: "A" } | { type: "B" };

			export type InternallyTaggedM = { type: "A" };

			export type InternallyTaggedMInner = "A" | "B";

			export type InternallyTaggedWithAlias = { type: "A"; field: string } | { type: "B"; other: number };

			export type InvalidToValidType = {
				cause: null | null,
			};

			export type Issue281 = {
				default_unity_arguments: string[],
			};

			/**
			 *  https://github.com/specta-rs/specta/issues/374
			 */
			export type Issue374 = {
				foo?: boolean,
				bar?: boolean,
			};

			export type KebabCase = {
				"test-ing": string,
			};

			export type LoadProjectEvent = { event: "started"; data: {
	projectName: string,
} } | { event: "progressTest"; data: {
	projectName: string,
	status: string,
	progress: number,
} } | { event: "finished"; data: {
	projectName: string,
} };

			export type MacroEnum = { Demo: string } | { Demo2: { demo2: string } };

			export type MacroStruct = string;

			export type MacroStruct2 = {
				demo: string,
			};

			export type MyEmptyInput = Record<string, never>;

			export type MyEnum = { A: string } | { B: number };

			export type MyEnumAdjacent = { t: "Variant"; c: ($s$.test.types.First) };

			export type MyEnumExternal = { Variant: ($s$.test.types.First) };

			export type MyEnumTagged = ($s$.test.types.First) & { type: "Variant" };

			export type MyEnumUntagged = ($s$.test.types.First);

			export type NestedEnum = { type: "a"; value: string } | { type: "b"; value: number };

			export type NonOptional = string | null;

			export type Optional = {
				a: number | null,
				b?: number | null,
				c?: string | null,
				d?: boolean,
			};

			export type OptionalInEnum = { A: string | null } | { B: { a: string | null } } | { C: { a?: string | null } };

			export type OptionalOnNamedField = string | null;

			export type OptionalOnTransparentNamedField = {
				b: string | null,
			};

			export type OverridenStruct = {
				overriden_field: string,
			};

			export type Pair<Z, A> = {
				first: Z,
				second: A,
			};

			export type PlaceholderInnerField = {
				a: string,
			};

			export type Recursive = {
				demo: $s$.test.types.Recursive,
			};

			export type RecursiveInEnum = { A: ($s$.test.types.RecursiveInEnum) };

			export type RecursiveInline = ($s$.test.types.RecursiveInline);

			export type RecursiveMapValue = {
				demo: { [key in string]: $s$.test.types.RecursiveMapValue },
			};

			export type RecursiveTransparent = $s$.test.types.RecursiveInline;

			export type RefStruct = $s$.test.types.TestEnum;

			export type Regular = { [key in string]: null };

			export type Rename = "OneWord" | "Two words";

			export type RenameSerdeSpecialChar = {
				"a/b": number,
			};

			export type RenameWithWeirdCharsField = {
				"@odata.context": string,
			};

			export type RenameWithWeirdCharsVariant = { "@odata.context": string };

			export type Second = {
				a: number,
			};

			export type Seventh = {
				a: $s$.test.types.First,
				b: $s$.test.types.Second,
			};

			export type SimpleStruct = {
				a: number,
				b: string,
				c: [number, string, number],
				d: string[],
				e: string | null,
			};

			/**
			 *  Some single-line comment
			 */
			export type SingleLineComment = 
			/**
			 *  Some single-line comment
			 */
{ A: number } | 
			/**
			 *  Some single-line comment
			 */
{ B: { 
			/**
			 *  Some single-line comment
			 */
a: number } };

			export type Sixth = {
				a: $s$.test.types.First,
				b: $s$.test.types.First,
			};

			export type SkipField = {
				b: number,
			};

			export type SkipNamedFieldInVariant = { A: Record<string, never> } | { B: { b: number } };

			export type SkipOnlyField = Record<string, never>;

			export type SkipOnlyVariantAdjacentlyTagged = never;

			export type SkipOnlyVariantExternallyTagged = never;

			export type SkipOnlyVariantInternallyTagged = never;

			export type SkipOnlyVariantUntagged = never;

			export type SkipStructFields = {
				a: number,
			};

			export type SkipUnnamedFieldInVariant = { A: [] } | { B: number };

			export type SkipVariant = { A: string };

			export type SkipVariant2 = { tag: "A"; data: string };

			export type SkipVariant3 = { A: { a: string } };

			export type SkippedFieldWithinVariant = { type: "A"; data: null } | { type: "B"; data: string };

			export type SpectaSkipNonTypeField = {
				a: number,
			};

			export type SpectaTypeOverride = {
				string_ident: string,
				u32_ident: number,
				path: string,
			};

			export type StructRenameAllUppercase = {
				A: number,
				B: number,
			};

			export type StructWithAlias = {
				field: string,
			};

			export type StructWithAliasAndRename = {
				renamed_field: string,
			};

			export type StructWithMultipleAliases = {
				field: string,
			};

			export type TagOnStructWithInline = {
				type: "TagOnStructWithInline",
				a: $s$.test.types.First,
				b: {
					a: string,
				},
			};

			export type TaggedEnumOfEmptyBracedStruct = { a: "A" } | { a: "B" };

			export type TaggedEnumOfEmptyTupleBracedStructs = { a: "B" };

			export type TaggedEnumOfEmptyTupleStruct = { a: "A" } | { a: "B" };

			export type TaggedEnumOfUnitStruct = { a: "A" } | { a: "B" };

			export type TaggedStructOfStructWithTuple = { a: "A" } | { a: "B" };

			export type Tenth = string | "B" | {
	a: string,
} | $s$.test.types.First;

			export type TestEnum = "Unit" | { Single: number } | { Multiple: [number, number] } | { Struct: { a: number } };

			export type Third = ($s$.test.types.First) & {
				b: { [key in string]: string },
				c: $s$.test.types.First,
			};

			export type ToBeFlattened = {
				a: string,
			};

			export type TransparentType = $s$.test.types.TransparentTypeInner;

			export type TransparentType2 = null;

			export type TransparentTypeInner = {
				inner: string,
			};

			export type TransparentTypeWithOverride = string;

			export type TransparentWithSkip = null;

			export type TransparentWithSkip2 = string;

			export type TransparentWithSkip3 = string;

			export type TupleNested = [number[], [number[], number[]], [number[], number[], number[]]];

			export type TupleStruct = string;

			export type TupleStruct1 = number;

			export type TupleStruct3 = [number, boolean, string];

			export type TupleStructWithRep = string;

			export type TupleStructWithTuple = null;

			export type Unit1 = null;

			export type Unit2 = Record<string, never>;

			export type Unit3 = [];

			export type Unit4 = null;

			export type Unit5 = "A";

			export type Unit6 = { A: [] };

			export type Unit7 = { A: Record<string, never> };

			export type UnitStruct = null;

			export type UnitVariants = "A" | "B" | "C";

			export type UntaggedVariants = string | number | { id: string } | [string, boolean];

			export type UntaggedVariantsKey = string | number;

			export type UntaggedVariantsWithoutValue = string | [number, string] | number;

			export type UntaggedWithAlias = { field: string } | { other: number };

			export type Variants = { A: string } | { B: number } | { C: number };

			export namespace type_type {

				export type Type = never;
			}
		}

		export namespace typescript {

			export type TestCollectionRegister = never;
		}
	}

	export namespace tests {

		export namespace tests {

			export namespace types {

				export type Primitives = {
					"1": number,
					"2": number,
					"3": number,
					"4": number,
					"5": number,
					"6": number,
					"7": number,
					"8": number,
					"9": number,
					a: number,
					b: number,
					c: number,
					d: number,
					e: number,
					f: boolean,
					"10": string,
					"11": {
						start: number,
						end: number,
					},
					"12": {
						start: number,
						end: number,
					},
					"13": null,
					"14": [string, number],
					"15": [string, number, boolean],
					"16": [[string, number], [boolean, string, boolean], null],
					"17": [boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean],
					"18": [number[], boolean[]],
					"19": string,
					"1a": string,
					"1b": string,
					"1c": string,
					"1d": string,
					"1e": string,
					"1f": string,
					"20": string,
					"21": string,
					"22": number,
					"23": {
						duration_since_epoch: number,
						duration_since_unix_epoch: number,
					},
					"24": {
						secs: number,
						nanos: number,
					},
					"25": string,
					"26": boolean,
					"27": number,
					"28": number[],
					"29": number[],
					"2a": [number, number, number],
					"2b": [number, number, number],
					"2c": $s$.test.types.MyEnum[],
					"2d": $s$.test.types.MyEnum[],
					"2e": [$s$.test.types.MyEnum, $s$.test.types.MyEnum, $s$.test.types.MyEnum, $s$.test.types.MyEnum, $s$.test.types.MyEnum, $s$.test.types.MyEnum],
					"2f": [$s$.test.types.MyEnum, $s$.test.types.MyEnum],
					"30": [number],
					"31": [],
					"32": number | null,
					"33": null | null,
					"34": number[] | null,
					"35": (number | null)[],
					"36": number[] | null,
					"37": [string[], string[], string[]],
					"38": string | null,
					"39": string | null,
					"3a": null,
					"3b": null,
					"3c": never,
					"3d": $s$.test.types.Unit1,
					"3e": $s$.test.types.Unit2,
					"3f": $s$.test.types.Unit3,
					"40": $s$.test.types.Unit4,
					"41": $s$.test.types.Unit5,
					"42": $s$.test.types.Unit6,
					"43": $s$.test.types.Unit7,
					"44": $s$.test.types.SimpleStruct,
					"45": $s$.test.types.TupleStruct1,
					"46": $s$.test.types.TupleStruct3,
					"47": $s$.test.types.TestEnum,
					"48": $s$.test.types.RefStruct,
					"49": $s$.test.types.InlinerStruct,
					"4a": $s$.test.types.GenericStruct<number>,
					"4b": $s$.test.types.GenericStruct<string>,
					"4c": $s$.test.types.FlattenEnumStruct,
					"4d": $s$.test.types.OverridenStruct,
					"4e": $s$.test.types.HasGenericAlias,
					"4f": $s$.test.types.EnumMacroAttributes,
					"50": $s$.test.types.InlineEnumField,
					"51": $s$.test.types.InlineOptionalType,
					"52": $s$.test.types.Rename,
					"53": $s$.test.types.TransparentType,
					"54": $s$.test.types.TransparentType2,
					"55": $s$.test.types.TransparentTypeWithOverride,
					"56": [(number | null), (number | null), (number | null)],
					"57": Partial<{ [key in $s$.test.types.BasicEnum]: null }>,
					"58": number | null,
					"59": $s$.test.types.PlaceholderInnerField[],
					"5a": Partial<{ [key in $s$.test.types.BasicEnum]: number }>,
					"5b": $s$.test.types.EnumReferenceRecordKey,
					"5c": $s$.test.types.FlattenOnNestedEnum,
					"5d": $s$.test.types.MyEmptyInput,
					"5e": string,
					"5f": [string],
					"60": $s$.test.types.ExtraBracketsInTupleVariant,
					"61": $s$.test.types.ExtraBracketsInUnnamedStruct,
					"62": $s$.test.types.MyEnum[],
					"63": $s$.test.types.InlineTuple,
					"64": $s$.test.types.InlineTuple2,
					"65": string,
					"66": string,
					"67": $s$.test.types.SkippedFieldWithinVariant,
					"68": $s$.test.types.KebabCase,
					"69": string[],
					"6a": $s$.test.types.Issue281,
					"6b": $s$.test.types.RenameWithWeirdCharsField,
					"6c": $s$.test.types.RenameWithWeirdCharsVariant,
					"6d": $s$.test.types.Issue374,
					"6e": $s$.test.types.type_type.Type,
					"6f": $s$.test.types.ActualType,
					"70": $s$.test.types.SpectaTypeOverride,
					"71": $s$.test.types.InvalidToValidType,
					"72": $s$.test.types.TupleStruct,
					"73": $s$.test.types.TupleStructWithRep,
					"74": $s$.test.types.GenericTupleStruct<string>,
					"75": $s$.test.types.BracedStruct,
					"76": $s$.test.types.StructRenameAllUppercase,
					"77": $s$.test.types.RenameSerdeSpecialChar,
					"78": $s$.test.types.EnumRenameAllUppercase,
					"79": $s$.test.types.Recursive,
					"7a": $s$.test.types.RecursiveMapValue,
					"7b": $s$.test.types.RecursiveTransparent,
					"7c": $s$.test.types.RecursiveInEnum,
					"7d": $s$.test.types.NonOptional,
					"7e": $s$.test.types.OptionalOnNamedField,
					"7f": $s$.test.types.OptionalOnTransparentNamedField,
					"80": $s$.test.types.OptionalInEnum,
					"81": $s$.test.types.Optional,
					"82": $s$.test.types.UntaggedVariants,
					"83": $s$.test.types.UntaggedVariantsWithoutValue,
					"84": { [key in string]: null },
					"85": $s$.test.types.Regular,
					"86": { [key in never]: null },
					"87": Partial<{ [key in $s$.test.types.UnitVariants]: null }>,
					"88": Partial<{ [key in $s$.test.types.UntaggedVariantsKey]: null }>,
					"89": Partial<{ [key in $s$.test.types.Variants]: null }>,
					"8a": $s$.test.types.MacroStruct,
					"8b": $s$.test.types.MacroStruct2,
					"8c": $s$.test.types.MacroEnum,
					"8d": $s$.test.types.DeprecatedType,
					"8e": $s$.test.types.DeprecatedTypeWithMsg,
					"8f": $s$.test.types.DeprecatedTypeWithMsg2,
					"90": $s$.test.types.DeprecatedFields,
					"91": $s$.test.types.DeprecatedTupleVariant,
					"92": $s$.test.types.DeprecatedEnumVariants,
					"93": $s$.test.types.CommentedStruct,
					"94": $s$.test.types.CommentedEnum,
					"95": $s$.test.types.SingleLineComment,
					"96": $s$.test.types.Demo<number, boolean>,
					"97": $s$.test.types.Demo<number, boolean>,
					"98": $s$.test.types.Demo<number, boolean>,
					"99": $s$.test.types.Demo<number, boolean>,
					"9a": $s$.test.types.Demo<number, boolean>,
					"9b": { [key in string]: number },
					"9c": { [key in number]: string },
					"9d": { [key in string]: $s$.test.types.AGenericStruct<number> },
					"9e": $s$.test.types.AGenericStruct<number>,
					"9f": $s$.test.types.A,
					a0: $s$.test.types.DoubleFlattened,
					a1: $s$.test.types.FlattenedInner,
					a2: $s$.test.types.BoxFlattened,
					a3: $s$.test.types.BoxInline,
					a4: $s$.test.types.First,
					a5: $s$.test.types.Second,
					a6: $s$.test.types.Third,
					a7: $s$.test.types.Fourth,
					a8: $s$.test.types.TagOnStructWithInline,
					a9: $s$.test.types.Sixth,
					aa: $s$.test.types.Seventh,
					ab: $s$.test.types.Eight,
					ac: $s$.test.types.Tenth,
					ad: $s$.test.types.MyEnumTagged,
					ae: $s$.test.types.MyEnumExternal,
					af: $s$.test.types.MyEnumAdjacent,
					b0: $s$.test.types.MyEnumUntagged,
					b1: $s$.test.types.EmptyStruct,
					b2: $s$.test.types.EmptyStructWithTag,
					b3: $s$.test.types.AdjacentlyTagged,
					b4: $s$.test.types.LoadProjectEvent,
					b5: $s$.test.types.ExternallyTagged,
					b6: $s$.test.types.InternallyTaggedB,
					b7: $s$.test.types.InternallyTaggedC,
					b8: $s$.test.types.InternallyTaggedD,
					b9: $s$.test.types.InternallyTaggedE,
					ba: $s$.test.types.InternallyTaggedF,
					bb: $s$.test.types.InternallyTaggedG,
					bc: $s$.test.types.InternallyTaggedH,
					bd: $s$.test.types.InternallyTaggedI,
					be: $s$.test.types.InternallyTaggedL,
					bf: $s$.test.types.InternallyTaggedM,
					c0: $s$.test.types.StructWithAlias,
					c1: $s$.test.types.StructWithMultipleAliases,
					c2: $s$.test.types.StructWithAliasAndRename,
					c3: $s$.test.types.EnumWithVariantAlias,
					c4: $s$.test.types.EnumWithMultipleVariantAliases,
					c5: $s$.test.types.EnumWithVariantAliasAndRename,
					c6: $s$.test.types.InternallyTaggedWithAlias,
					c7: $s$.test.types.AdjacentlyTaggedWithAlias,
					c8: $s$.test.types.UntaggedWithAlias,
					c9: $s$.test.types.EmptyEnum,
					ca: $s$.test.types.EmptyEnumTagged,
					cb: $s$.test.types.EmptyEnumTaggedWContent,
					cc: $s$.test.types.EmptyEnumUntagged,
					cd: $s$.test.types.TaggedEnumOfUnitStruct,
					ce: $s$.test.types.TaggedEnumOfEmptyBracedStruct,
					cf: $s$.test.types.TaggedEnumOfEmptyTupleStruct,
					d0: $s$.test.types.TaggedEnumOfEmptyTupleBracedStructs,
					d1: $s$.test.types.TaggedStructOfStructWithTuple,
					d2: $s$.test.types.SkipOnlyField,
					d3: $s$.test.types.SkipField,
					d4: $s$.test.types.SkipOnlyVariantExternallyTagged,
					d5: $s$.test.types.SkipOnlyVariantInternallyTagged,
					d6: $s$.test.types.SkipOnlyVariantAdjacentlyTagged,
					d7: $s$.test.types.SkipOnlyVariantUntagged,
					d8: $s$.test.types.SkipVariant,
					d9: $s$.test.types.SkipUnnamedFieldInVariant,
					da: $s$.test.types.SkipNamedFieldInVariant,
					db: $s$.test.types.TransparentWithSkip,
					dc: $s$.test.types.TransparentWithSkip2,
					dd: $s$.test.types.TransparentWithSkip3,
					de: $s$.test.types.SkipVariant2,
					df: $s$.test.types.SkipVariant3,
					e0: $s$.test.types.SkipStructFields,
					e1: $s$.test.types.SpectaSkipNonTypeField,
					e2: $s$.test.types.FlattenA,
					e3: $s$.test.types.FlattenB,
					e4: $s$.test.types.FlattenC,
					e5: $s$.test.types.FlattenD,
					e6: $s$.test.types.FlattenE,
					e7: $s$.test.types.FlattenF,
					e8: $s$.test.types.FlattenG,
					e9: $s$.test.types.TupleNested,
					ea: $s$.test.types.Generic1<null>,
					eb: $s$.test.types.GenericAutoBound<null>,
					ec: $s$.test.types.GenericAutoBound2<null>,
					ed: $s$.test.types.Container1,
					ee: $s$.test.types.Generic2<null, string, number>,
					ef: $s$.test.types.GenericNewType1<null>,
					f0: $s$.test.types.GenericTuple<null>,
					f1: $s$.test.types.GenericStruct2<null>,
					f2: string,
					f3: [string, string[], [string, string], { [key in string]: string }, string | null, "Unit" | { Unnamed: string } | { Named: { value: string } }],
					f4: $s$.test.types.InlineFlattenGenericsG<null>,
					f5: $s$.test.types.InlineFlattenGenerics,
					f6: $s$.test.types.GenericParameterOrderPreserved,
				};
			}
		}
	}
}
export import test = $s$.test;
export import tests = $s$.tests;
════════════════════════════════════════
