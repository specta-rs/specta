---
source: tests/tests/typescript.rs
expression: fs_to_string(&path).unwrap()
---
ts-export-to-namespaces-both (27129 bytes)
────────────────────────────────────────
// This file has been generated by Specta. Do not edit this file manually.
export namespace test {
    export namespace types {
        export type A = { 
		a: $specta$root$test$.types.B,
		b: $specta$root$test$.types.B,
		c: $specta$root$test$.types.B,
		d: $specta$root$test$.types.D,
		e: $specta$root$test$.types.GenericFlattened<number>,
	};

        export type AGenericStruct<T> = { 
		field: $specta$root$test$.types.Demo<T, boolean>,
	};

        export type ActualType = { 
		a: $specta$root$test$.types.GenericType<string>,
	};

        export type AdjacentlyTagged = { t: "A" } | { t: "B"; c: { 
	id: string,
	method: string,
} } | { t: "C"; c: string };

        export type AdjacentlyTaggedWithAlias = { type: "A"; data: { 
	field: string,
} } | { type: "B"; data: { 
	other: number,
} };

        export type B = { 
		b: number,
	};

        export type BasicEnum = "A" | "B";

        export type BoxFlattened = { 
		b: $specta$root$test$.types.BoxedInner,
	};

        export type BoxInline = { 
		c: $specta$root$test$.types.BoxedInner,
	};

        export type BoxedInner = { 
		a: number,
	};

        export type BracedStruct = string;

        /**
 * Some triple-slash comment
 * Some more triple-slash comment
 */
export type CommentedEnum = 
	/**
 * Some triple-slash comment
 * Some more triple-slash comment
 */
{ A: number } | 
	/**
 * Some triple-slash comment
 * Some more triple-slash comment
 */
{ B: { 
	/**
 * Some triple-slash comment
 * Some more triple-slash comment
 */
a: number } };

        /**
 * Some triple-slash comment
 * Some more triple-slash comment
 */
export type CommentedStruct = { 
		
	/**
 * Some triple-slash comment
 * Some more triple-slash comment
 */
a: number,
	};

        export type Container1 = { 
		foo: $specta$root$test$.types.Generic1<number>,
		bar: $specta$root$test$.types.Generic1<number>[],
		baz: { [key in string]: $specta$root$test$.types.Generic1<string> },
	};

        export type D = { 
		flattened: number,
	};

        export type Demo<A, B> = { 
		a: A,
		b: B,
	};

        export type DeprecatedEnumVariants = 
	/**
 * @deprecated
 */
"A" | 
	/**
 * @deprecated Nope
 */
"B" | 
	/**
 * @deprecated Nope
 */
"C";

        export type DeprecatedFields = { 
		a: number,
		
	/**
 * @deprecated
 */
b: string,
		
	/**
 * @deprecated This field is cringe!
 */
c: string,
		
	/**
 * @deprecated This field is cringe!
 */
d: string,
	};

        export type DeprecatedTupleVariant = [
	/**
 * @deprecated
 */
string, 
	/**
 * @deprecated Nope
 */
string, 
	/**
 * @deprecated Nope
 */
number];

        /**
 * @deprecated
 */
export type DeprecatedType = { 
		a: number,
	};

        /**
 * @deprecated Look at you big man using a deprecation message
 */
export type DeprecatedTypeWithMsg = { 
		a: number,
	};

        /**
 * @deprecated Look at you big man using a deprecation message
 */
export type DeprecatedTypeWithMsg2 = { 
		a: number,
	};

        export type DoubleFlattened = { 
		a: $specta$root$test$.types.ToBeFlattened,
		b: $specta$root$test$.types.ToBeFlattened,
	};

        export type Eight = { A: string } | "B";

        export type EmptyBracedStruct = Record<string, never>;

        export type EmptyEnum = never;

        export type EmptyEnumTagged = never;

        export type EmptyEnumTaggedWContent = never;

        export type EmptyEnumUntagged = never;

        export type EmptyStruct = Record<string, never>;

        export type EmptyStructWithTag = { 
		a: "EmptyStructWithTag",
	};

        export type EmptyTupleStruct = [];

        export type EnumMacroAttributes = { A: string } | { bbb: number } | { cccc: number } | { D: { a: string; b: number } };

        export type EnumReferenceRecordKey = { 
		a: Partial<{ [key in $specta$root$test$.types.BasicEnum]: number }>,
	};

        export type EnumRenameAllUppercase = "HELLOWORLD" | "VARIANTB" | "TESTINGWORDS";

        export type EnumWithMultipleVariantAliases = "Variant" | "Other";

        export type EnumWithVariantAlias = "Variant" | "Other";

        export type EnumWithVariantAliasAndRename = "renamed_variant" | "Other";

        export type ExternallyTagged = "A" | { B: { id: string; method: string } } | { C: string };

        export type ExtraBracketsInTupleVariant = { A: string };

        export type ExtraBracketsInUnnamedStruct = string;

        export type First = { 
		a: string,
	};

        export type FlattenA = { 
		a: number,
		b: number,
	};

        export type FlattenB = ($specta$root$test$.types.FlattenA) & { 
		c: number,
	};

        export type FlattenC = ($specta$root$test$.types.FlattenA) & { 
		c: number,
	};

        export type FlattenD = { 
		a: $specta$root$test$.types.FlattenA,
		c: number,
	};

        export type FlattenE = { 
		b: $specta$root$test$.types.FlattenB,
		d: number,
	};

        export type FlattenEnum = { tag: "One" } | { tag: "Two" } | { tag: "Three" };

        export type FlattenEnumStruct = ($specta$root$test$.types.FlattenEnum) & { 
		outer: string,
	};

        export type FlattenF = { 
		b: $specta$root$test$.types.FlattenB,
		d: number,
	};

        export type FlattenG = { 
		b: $specta$root$test$.types.FlattenB,
		d: number,
	};

        export type FlattenOnNestedEnum = ($specta$root$test$.types.NestedEnum) & { 
		id: string,
	};

        export type FlattenedInner = { 
		c: $specta$root$test$.types.Inner,
	};

        export type Fourth = { 
		a: $specta$root$test$.types.First,
		b: $specta$root$test$.types.First,
	};

        export type Generic1<T> = { 
		value: T,
		values: T[],
	};

        export type Generic2<A, B, C> = { A: A } | { B: [B, B, B] } | { C: C[] } | { D: A[][][] } | { E: { a: A; b: B; c: C } } | { X: number[] } | { Y: number } | { Z: number[][] };

        export type GenericAutoBound<T> = { 
		value: T,
		values: T[],
	};

        export type GenericAutoBound2<T> = { 
		value: T,
		values: T[],
	};

        export type GenericFlattened<T> = { 
		generic_flattened: T,
	};

        export type GenericNewType1<T> = T[][];

        export type GenericParameterOrderPreserved = { 
		pair: $specta$root$test$.types.Pair<number, string>,
	};

        export type GenericStruct<T> = { 
		arg: T,
	};

        export type GenericStruct2<T> = { 
		a: T,
		b: [T, T],
		c: [T, [T, T]],
		d: T[],
		e: ([T, T])[],
		f: T[],
		g: T[][],
		h: (([T, T])[])[],
	};

        export type GenericTuple<T> = [T, T[], T[][]];

        export type GenericTupleStruct<T> = T;

        export type GenericType<T> = "Undefined" | T;

        export type HasGenericAlias = { [key in number]: string };

        export type InlineEnumField = { A: $specta$root$test$.types.PlaceholderInnerField };

        export type InlineFlattenGenerics = ($specta$root$test$.types.InlineFlattenGenericsG<string>) & { 
		g: $specta$root$test$.types.InlineFlattenGenericsG<string>,
		gi: $specta$root$test$.types.InlineFlattenGenericsG<string>,
	};

        export type InlineFlattenGenericsG<T> = { 
		t: T,
	};

        export type InlineOptionalType = { 
		optional_field: $specta$root$test$.types.PlaceholderInnerField | null,
	};

        export type InlineStruct = { 
		ref_struct: $specta$root$test$.types.SimpleStruct,
		val: number,
	};

        export type InlineTuple = { 
		demo: [string, boolean],
	};

        export type InlineTuple2 = { 
		demo: [$specta$root$test$.types.InlineTuple, boolean],
	};

        export type InlinerStruct = { 
		inline_this: $specta$root$test$.types.InlineStruct,
		dont_inline_this: $specta$root$test$.types.RefStruct,
	};

        export type Inner = { 
		a: number,
		b: $specta$root$test$.types.FlattenedInner,
	};

        export type InternallyTaggedB = { type: "A" };

        export type InternallyTaggedC = { type: "A" };

        export type InternallyTaggedD = { type: "A" };

        export type InternallyTaggedE = { type: "A" };

        export type InternallyTaggedF = { type: "A" };

        export type InternallyTaggedFInner = null;

        export type InternallyTaggedG = { type: "A" };

        export type InternallyTaggedGInner = string;

        export type InternallyTaggedH = { type: "A" };

        export type InternallyTaggedHInner = null;

        export type InternallyTaggedI = { type: "A" };

        export type InternallyTaggedIInner = string;

        export type InternallyTaggedL = { type: "A" };

        export type InternallyTaggedLInner = { type: "A" } | { type: "B" };

        export type InternallyTaggedM = { type: "A" };

        export type InternallyTaggedMInner = "A" | "B";

        export type InternallyTaggedWithAlias = { type: "A"; field: string } | { type: "B"; other: number };

        export type InvalidToValidType = { 
		cause: null | null,
	};

        export type Issue281 = { 
		default_unity_arguments: string[],
	};

        /**
 * https://github.com/specta-rs/specta/issues/374
 */
export type Issue374 = { 
		foo: boolean,
		bar: boolean,
	};

        export type KebabCase = { 
		"test-ing": string,
	};

        export type LoadProjectEvent = { event: "started"; data: { 
	projectName: string,
} } | { event: "progressTest"; data: { 
	projectName: string,
	status: string,
	progress: number,
} } | { event: "finished"; data: { 
	projectName: string,
} };

        export type MacroEnum = { Demo: string } | { Demo2: { demo2: string } };

        export type MacroStruct = string;

        export type MacroStruct2 = { 
		demo: string,
	};

        export type MyEmptyInput = Record<string, never>;

        export type MyEnum = { A: string } | { B: number };

        export type MyEnumAdjacent = { t: "Variant"; c: ($specta$root$test$.types.First) };

        export type MyEnumExternal = { Variant: ($specta$root$test$.types.First) };

        export type MyEnumTagged = ($specta$root$test$.types.First) & { type: "Variant" };

        export type MyEnumUntagged = ($specta$root$test$.types.First);

        export type NestedEnum = { type: "a"; value: string } | { type: "b"; value: number };

        export type NonOptional = string | null;

        export type Optional = { 
		a: number | null,
		b?: number | null,
		c: string | null,
		d: boolean,
	};

        export type OptionalInEnum = { A: string | null } | { B: { a: string | null } } | { C: { a?: string | null } };

        export type OptionalOnNamedField = string | null;

        export type OptionalOnTransparentNamedField = { 
		b: string | null,
	};

        export type OptionalOnTransparentNamedFieldInner = string | null;

        export type OverridenStruct = { 
		overriden_field: string,
	};

        export type Pair<Z, A> = { 
		first: Z,
		second: A,
	};

        export type PlaceholderInnerField = { 
		a: string,
	};

        export type Recursive = { 
		demo: $specta$root$test$.types.Recursive,
	};

        export type RecursiveInEnum = { A: ($specta$root$test$.types.RecursiveInEnum) };

        export type RecursiveInline = ($specta$root$test$.types.RecursiveInline);

        export type RecursiveMapValue = { 
		demo: { [key in string]: $specta$root$test$.types.RecursiveMapValue },
	};

        export type RecursiveTransparent = $specta$root$test$.types.RecursiveInline;

        export type RefStruct = $specta$root$test$.types.TestEnum;

        export type Regular = { [key in string]: null };

        export type Rename = "OneWord" | "Two words";

        export type RenameSerdeSpecialChar = { 
		b: number,
	};

        export type RenameWithWeirdCharsField = { 
		odata_context: string,
	};

        export type RenameWithWeirdCharsVariant = { "@odata.context": string };

        export type Second = { 
		a: number,
	};

        export type Seventh = { 
		a: $specta$root$test$.types.First,
		b: $specta$root$test$.types.Second,
	};

        export type SimpleStruct = { 
		a: number,
		b: string,
		c: [number, string, number],
		d: string[],
		e: string | null,
	};

        /**
 * Some single-line comment
 */
export type SingleLineComment = 
	/**
 * Some single-line comment
 */
{ A: number } | 
	/**
 * Some single-line comment
 */
{ B: { 
	/**
 * Some single-line comment
 */
a: number } };

        export type Sixth = { 
		a: $specta$root$test$.types.First,
		b: $specta$root$test$.types.First,
	};

        export type SkipField = { 
		b: number,
	};

        export type SkipNamedFieldInVariant = { A: Record<string, never> } | { B: { b: number } };

        export type SkipOnlyField = Record<string, never>;

        export type SkipOnlyVariantAdjacentlyTagged = never;

        export type SkipOnlyVariantExternallyTagged = never;

        export type SkipOnlyVariantInternallyTagged = never;

        export type SkipOnlyVariantUntagged = never;

        export type SkipStructFields = { 
		a: number,
	};

        export type SkipUnnamedFieldInVariant = { A: [] } | { B: number };

        export type SkipVariant = { A: string };

        export type SkipVariant2 = { tag: "A"; data: string };

        export type SkipVariant3 = { A: { a: string } };

        export type SkippedFieldWithinVariant = { type: "A"; data: null } | { type: "B"; data: string };

        export type SpectaSkipNonTypeField = { 
		a: number,
	};

        export type SpectaTypeOverride = { 
		string_ident: string,
		u32_ident: number,
		path: string,
	};

        export type StructRenameAllUppercase = { 
		A: number,
		B: number,
	};

        export type StructWithAlias = { 
		field: string,
	};

        export type StructWithAliasAndRename = { 
		field: string,
	};

        export type StructWithMultipleAliases = { 
		field: string,
	};

        export type TagOnStructWithInline = { 
		type: "TagOnStructWithInline",
		a: $specta$root$test$.types.First,
		b: $specta$root$test$.types.First,
	};

        export type TaggedEnumOfEmptyBracedStruct = { a: "A" } | { a: "B" };

        export type TaggedEnumOfEmptyTupleBracedStructs = { a: "B" };

        export type TaggedEnumOfEmptyTupleStruct = { a: "A" } | { a: "B" };

        export type TaggedEnumOfUnitStruct = { a: "A" } | { a: "B" };

        export type TaggedStructOfStructWithTuple = { a: "A" } | { a: "B" };

        export type Tenth = string | "B" | $specta$root$test$.types.First;

        export type TestEnum = "Unit" | { Single: number } | { Multiple: [number, number] } | { Struct: { a: number } };

        export type Third = ($specta$root$test$.types.First) & { 
		b: { [key in string]: string },
		c: $specta$root$test$.types.First,
	};

        export type ToBeFlattened = { 
		a: string,
	};

        export type TransparentType = $specta$root$test$.types.TransparentTypeInner;

        export type TransparentType2 = null;

        export type TransparentTypeInner = { 
		inner: string,
	};

        export type TransparentTypeWithOverride = string;

        export type TransparentWithSkip = null;

        export type TransparentWithSkip2 = string;

        export type TransparentWithSkip3 = string;

        export type TupleNested = [number[], [number[], number[]], number[][]];

        export type TupleStruct = string;

        export type TupleStruct1 = number;

        export type TupleStruct3 = [number, boolean, string];

        export type TupleStructWithRep = string;

        export type TupleStructWithTuple = null;

        export type Unit1 = null;

        export type Unit2 = Record<string, never>;

        export type Unit3 = [];

        export type Unit4 = null;

        export type Unit5 = "A";

        export type Unit6 = { A: [] };

        export type Unit7 = { A: Record<string, never> };

        export type UnitStruct = null;

        export type UnitVariants = "A" | "B" | "C";

        export type UntaggedVariants = string | number | { id: string } | [string, boolean];

        export type UntaggedVariantsKey = string | number;

        export type UntaggedVariantsWithoutValue = string | [number, string] | number;

        export type UntaggedWithAlias = { field: string } | { other: number };

        export type Variants = { A: string } | { B: number } | { C: number };


        export namespace selection {
            export type UserListSelection<name, age> = { 
		name: name,
		age: age,
	};

            export type UserSelection<name, age> = { 
		name: name,
		age: age,
	};

        }

        export namespace type_type {
            export type Type = never;

        }
    }

    export namespace typescript {
        export type TestCollectionRegister = never;

    }
}

export namespace virtual {
    export type Primitives = { 
		"1": number,
		"2": number,
		"3": number,
		"4": number,
		"5": number,
		"6": number,
		"7": number,
		"8": number,
		"9": number,
		a: number,
		b: number,
		c: number,
		d: number,
		e: number,
		f: boolean,
		"10": string,
		"11": { 
	start: number,
	end: number,
},
		"12": { 
	start: number,
	end: number,
},
		"13": null,
		"14": [string, number],
		"15": [string, number, boolean],
		"16": [[string, number], [boolean, string, boolean], null],
		"17": [boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean],
		"18": [number[], boolean[]],
		"19": string,
		"1a": string,
		"1b": string,
		"1c": string,
		"1d": string,
		"1e": string,
		"1f": string,
		"20": string,
		"21": string,
		"22": number,
		"23": { 
	duration_since_epoch: number,
	duration_since_unix_epoch: number,
},
		"24": { 
	secs: number,
	nanos: number,
},
		"25": string,
		"26": boolean,
		"27": number,
		"28": number[],
		"29": number[],
		"2a": number[],
		"2b": number[],
		"2c": $specta$root$test$.types.MyEnum[],
		"2d": $specta$root$test$.types.MyEnum[],
		"2e": $specta$root$test$.types.MyEnum[],
		"2f": $specta$root$test$.types.MyEnum[],
		"30": number[],
		"31": number[],
		"32": number | null,
		"33": null | null,
		"34": number[] | null,
		"35": (number | null)[],
		"36": number[] | null,
		"37": string[][],
		"38": string | null,
		"39": string | null,
		"3a": null,
		"3b": null,
		"3c": never,
		"3d": $specta$root$test$.types.Unit1,
		"3e": $specta$root$test$.types.Unit2,
		"3f": $specta$root$test$.types.Unit3,
		"40": $specta$root$test$.types.Unit4,
		"41": $specta$root$test$.types.Unit5,
		"42": $specta$root$test$.types.Unit6,
		"43": $specta$root$test$.types.Unit7,
		"44": $specta$root$test$.types.SimpleStruct,
		"45": $specta$root$test$.types.TupleStruct1,
		"46": $specta$root$test$.types.TupleStruct3,
		"47": $specta$root$test$.types.TestEnum,
		"48": $specta$root$test$.types.RefStruct,
		"49": $specta$root$test$.types.InlinerStruct,
		"4a": $specta$root$test$.types.GenericStruct<number>,
		"4b": $specta$root$test$.types.GenericStruct<string>,
		"4c": $specta$root$test$.types.FlattenEnumStruct,
		"4d": $specta$root$test$.types.OverridenStruct,
		"4e": $specta$root$test$.types.HasGenericAlias,
		"4f": $specta$root$test$.types.EnumMacroAttributes,
		"50": $specta$root$test$.types.InlineEnumField,
		"51": $specta$root$test$.types.InlineOptionalType,
		"52": $specta$root$test$.types.Rename,
		"53": $specta$root$test$.types.TransparentType,
		"54": $specta$root$test$.types.TransparentType2,
		"55": $specta$root$test$.types.TransparentTypeWithOverride,
		"56": (number | null)[],
		"57": Partial<{ [key in $specta$root$test$.types.BasicEnum]: null }>,
		"58": number | null,
		"59": $specta$root$test$.types.PlaceholderInnerField[],
		"5a": Partial<{ [key in $specta$root$test$.types.BasicEnum]: number }>,
		"5b": $specta$root$test$.types.EnumReferenceRecordKey,
		"5c": $specta$root$test$.types.FlattenOnNestedEnum,
		"5d": $specta$root$test$.types.MyEmptyInput,
		"5e": string,
		"5f": [string],
		"60": $specta$root$test$.types.ExtraBracketsInTupleVariant,
		"61": $specta$root$test$.types.ExtraBracketsInUnnamedStruct,
		"62": $specta$root$test$.types.MyEnum[],
		"63": $specta$root$test$.types.InlineTuple,
		"64": $specta$root$test$.types.InlineTuple2,
		"65": string,
		"66": string,
		"67": $specta$root$test$.types.SkippedFieldWithinVariant,
		"68": $specta$root$test$.types.KebabCase,
		"69": string[],
		"6a": $specta$root$test$.types.Issue281,
		"6b": $specta$root$test$.types.RenameWithWeirdCharsField,
		"6c": $specta$root$test$.types.RenameWithWeirdCharsVariant,
		"6d": $specta$root$test$.types.Issue374,
		"6e": $specta$root$test$.types.type_type.Type,
		"6f": $specta$root$test$.types.ActualType,
		"70": $specta$root$test$.types.SpectaTypeOverride,
		"71": $specta$root$test$.types.InvalidToValidType,
		"72": $specta$root$test$.types.TupleStruct,
		"73": $specta$root$test$.types.TupleStructWithRep,
		"74": $specta$root$test$.types.GenericTupleStruct<string>,
		"75": $specta$root$test$.types.BracedStruct,
		"76": $specta$root$test$.types.StructRenameAllUppercase,
		"77": $specta$root$test$.types.RenameSerdeSpecialChar,
		"78": $specta$root$test$.types.EnumRenameAllUppercase,
		"79": $specta$root$test$.types.Recursive,
		"7a": $specta$root$test$.types.RecursiveMapValue,
		"7b": $specta$root$test$.types.RecursiveTransparent,
		"7c": $specta$root$test$.types.RecursiveInEnum,
		"7d": $specta$root$test$.types.NonOptional,
		"7e": $specta$root$test$.types.OptionalOnNamedField,
		"7f": $specta$root$test$.types.OptionalOnTransparentNamedField,
		"80": $specta$root$test$.types.OptionalInEnum,
		"81": $specta$root$test$.types.Optional,
		"82": $specta$root$test$.types.UntaggedVariants,
		"83": $specta$root$test$.types.UntaggedVariantsWithoutValue,
		"84": { [key in string]: null },
		"85": $specta$root$test$.types.Regular,
		"86": { [key in never]: null },
		"87": Partial<{ [key in $specta$root$test$.types.UnitVariants]: null }>,
		"88": Partial<{ [key in $specta$root$test$.types.UntaggedVariantsKey]: null }>,
		"89": Partial<{ [key in $specta$root$test$.types.Variants]: null }>,
		"8a": $specta$root$test$.types.MacroStruct,
		"8b": $specta$root$test$.types.MacroStruct2,
		"8c": $specta$root$test$.types.MacroEnum,
		"8d": $specta$root$test$.types.DeprecatedType,
		"8e": $specta$root$test$.types.DeprecatedTypeWithMsg,
		"8f": $specta$root$test$.types.DeprecatedTypeWithMsg2,
		"90": $specta$root$test$.types.DeprecatedFields,
		"91": $specta$root$test$.types.DeprecatedTupleVariant,
		"92": $specta$root$test$.types.DeprecatedEnumVariants,
		"93": $specta$root$test$.types.CommentedStruct,
		"94": $specta$root$test$.types.CommentedEnum,
		"95": $specta$root$test$.types.SingleLineComment,
		"96": $specta$root$test$.types.Demo<number, boolean>,
		"97": $specta$root$test$.types.Demo<number, boolean>,
		"98": $specta$root$test$.types.Demo<number, boolean>,
		"99": $specta$root$test$.types.Demo<number, boolean>,
		"9a": $specta$root$test$.types.Demo<number, boolean>,
		"9b": { [key in string]: number },
		"9c": { [key in number]: string },
		"9d": { [key in string]: $specta$root$test$.types.AGenericStruct<number> },
		"9e": $specta$root$test$.types.AGenericStruct<number>,
		"9f": $specta$root$test$.types.A,
		a0: $specta$root$test$.types.DoubleFlattened,
		a1: $specta$root$test$.types.FlattenedInner,
		a2: $specta$root$test$.types.BoxFlattened,
		a3: $specta$root$test$.types.BoxInline,
		a4: $specta$root$test$.types.First,
		a5: $specta$root$test$.types.Second,
		a6: $specta$root$test$.types.Third,
		a7: $specta$root$test$.types.Fourth,
		a8: $specta$root$test$.types.TagOnStructWithInline,
		a9: $specta$root$test$.types.Sixth,
		aa: $specta$root$test$.types.Seventh,
		ab: $specta$root$test$.types.Eight,
		ac: $specta$root$test$.types.Tenth,
		ad: $specta$root$test$.types.MyEnumTagged,
		ae: $specta$root$test$.types.MyEnumExternal,
		af: $specta$root$test$.types.MyEnumAdjacent,
		b0: $specta$root$test$.types.MyEnumUntagged,
		b1: $specta$root$test$.types.EmptyStruct,
		b2: $specta$root$test$.types.EmptyStructWithTag,
		b3: $specta$root$test$.types.AdjacentlyTagged,
		b4: $specta$root$test$.types.LoadProjectEvent,
		b5: $specta$root$test$.types.ExternallyTagged,
		b6: $specta$root$test$.types.InternallyTaggedB,
		b7: $specta$root$test$.types.InternallyTaggedC,
		b8: $specta$root$test$.types.InternallyTaggedD,
		b9: $specta$root$test$.types.InternallyTaggedE,
		ba: $specta$root$test$.types.InternallyTaggedF,
		bb: $specta$root$test$.types.InternallyTaggedG,
		bc: $specta$root$test$.types.InternallyTaggedH,
		bd: $specta$root$test$.types.InternallyTaggedI,
		be: $specta$root$test$.types.InternallyTaggedL,
		bf: $specta$root$test$.types.InternallyTaggedM,
		c0: $specta$root$test$.types.StructWithAlias,
		c1: $specta$root$test$.types.StructWithMultipleAliases,
		c2: $specta$root$test$.types.StructWithAliasAndRename,
		c3: $specta$root$test$.types.EnumWithVariantAlias,
		c4: $specta$root$test$.types.EnumWithMultipleVariantAliases,
		c5: $specta$root$test$.types.EnumWithVariantAliasAndRename,
		c6: $specta$root$test$.types.InternallyTaggedWithAlias,
		c7: $specta$root$test$.types.AdjacentlyTaggedWithAlias,
		c8: $specta$root$test$.types.UntaggedWithAlias,
		c9: $specta$root$test$.types.EmptyEnum,
		ca: $specta$root$test$.types.EmptyEnumTagged,
		cb: $specta$root$test$.types.EmptyEnumTaggedWContent,
		cc: $specta$root$test$.types.EmptyEnumUntagged,
		cd: $specta$root$test$.types.TaggedEnumOfUnitStruct,
		ce: $specta$root$test$.types.TaggedEnumOfEmptyBracedStruct,
		cf: $specta$root$test$.types.TaggedEnumOfEmptyTupleStruct,
		d0: $specta$root$test$.types.TaggedEnumOfEmptyTupleBracedStructs,
		d1: $specta$root$test$.types.TaggedStructOfStructWithTuple,
		d2: $specta$root$test$.types.SkipOnlyField,
		d3: $specta$root$test$.types.SkipField,
		d4: $specta$root$test$.types.SkipOnlyVariantExternallyTagged,
		d5: $specta$root$test$.types.SkipOnlyVariantInternallyTagged,
		d6: $specta$root$test$.types.SkipOnlyVariantAdjacentlyTagged,
		d7: $specta$root$test$.types.SkipOnlyVariantUntagged,
		d8: $specta$root$test$.types.SkipVariant,
		d9: $specta$root$test$.types.SkipUnnamedFieldInVariant,
		da: $specta$root$test$.types.SkipNamedFieldInVariant,
		db: $specta$root$test$.types.TransparentWithSkip,
		dc: $specta$root$test$.types.TransparentWithSkip2,
		dd: $specta$root$test$.types.TransparentWithSkip3,
		de: $specta$root$test$.types.SkipVariant2,
		df: $specta$root$test$.types.SkipVariant3,
		e0: $specta$root$test$.types.SkipStructFields,
		e1: $specta$root$test$.types.SpectaSkipNonTypeField,
		e2: $specta$root$test$.types.FlattenA,
		e3: $specta$root$test$.types.FlattenB,
		e4: $specta$root$test$.types.FlattenC,
		e5: $specta$root$test$.types.FlattenD,
		e6: $specta$root$test$.types.FlattenE,
		e7: $specta$root$test$.types.FlattenF,
		e8: $specta$root$test$.types.FlattenG,
		e9: $specta$root$test$.types.TupleNested,
		ea: $specta$root$test$.types.Generic1<null>,
		eb: $specta$root$test$.types.GenericAutoBound<null>,
		ec: $specta$root$test$.types.GenericAutoBound2<null>,
		ed: $specta$root$test$.types.Container1,
		ee: $specta$root$test$.types.Generic2<null, string, number>,
		ef: $specta$root$test$.types.GenericNewType1<null>,
		f0: $specta$root$test$.types.GenericTuple<null>,
		f1: $specta$root$test$.types.GenericStruct2<null>,
		f2: $specta$root$test$.types.InlineFlattenGenericsG<null>,
		f3: $specta$root$test$.types.InlineFlattenGenerics,
		f4: $specta$root$test$.types.GenericParameterOrderPreserved,
	};

}

export import $specta$root$test$ = test;
export import $specta$root$virtual$ = virtual;
════════════════════════════════════════
