// This file has been generated by Specta. DO NOT EDIT.
import Foundation

/// Advanced example showcasing complex enum unions and their Swift representations
/// 
/// This example demonstrates how specta-swift handles complex enum scenarios
/// including nested types, generic enums, and custom Codable implementations.
/// Complex enum with mixed variant types
public enum ApiResult<T, E> {
    case ok(ApiResultOkData)
    case err(ApiResultErrData)
    case loading(ApiResultLoadingData)
}
public struct ApiResultOkData: Codable {
    public let data: T
    public let status: UInt16
    public let headers: [(String, String)]?
    public let timestamp: String
}

public struct ApiResultErrData: Codable {
    public let error: E
    public let code: UInt32
    public let message: String
    public let retryAfter: UInt64?

    private enum CodingKeys: String, CodingKey {
        case error = "error"
        case code = "code"
        case message = "message"
        case retryAfter = "retry_after"
    }
}

public struct ApiResultLoadingData: Codable {
    public let progress: Float
    public let estimatedCompletion: String?

    private enum CodingKeys: String, CodingKey {
        case progress = "progress"
        case estimatedCompletion = "estimated_completion"
    }
}

// MARK: - ApiResult Codable Implementation
extension ApiResult: Codable {
    private enum CodingKeys: String, CodingKey {
        case ok = "Ok"
        case err = "Err"
        case loading = "Loading"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .ok:
            let data = try container.decode(ApiResultOkData.self, forKey: .ok)
            self = .ok(data)
        case .err:
            let data = try container.decode(ApiResultErrData.self, forKey: .err)
            self = .err(data)
        case .loading:
            let data = try container.decode(ApiResultLoadingData.self, forKey: .loading)
            self = .loading(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .ok(let data):
            try container.encode(data, forKey: .ok)
        case .err(let data):
            try container.encode(data, forKey: .err)
        case .loading(let data):
            try container.encode(data, forKey: .loading)
        }
    }
}


public struct Color: Codable {
    public let red: Double
    public let green: Double
    public let blue: Double
    public let alpha: Double
}

/// Generic enum with constraints
public enum Container<T>: Codable {
    case empty
    case single(T)
    case multiple([T])
    case keyValue([(String, T)])
}

/// Event system enum
public enum Event {
    case user(EventUserData)
    case system(EventSystemData)
    case error(EventErrorData)
}
public struct EventUserData: Codable {
    public let userId: UInt32
    public let action: String
    public let timestamp: String

    private enum CodingKeys: String, CodingKey {
        case userId = "user_id"
        case action = "action"
        case timestamp = "timestamp"
    }
}

public struct EventSystemData: Codable {
    public let component: String
    public let level: String
    public let message: String
}

public struct EventErrorData: Codable {
    public let code: UInt32
    public let message: String
    public let stackTrace: String?

    private enum CodingKeys: String, CodingKey {
        case code = "code"
        case message = "message"
        case stackTrace = "stack_trace"
    }
}

// MARK: - Event Codable Implementation
extension Event: Codable {
    private enum CodingKeys: String, CodingKey {
        case user = "User"
        case system = "System"
        case error = "Error"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .user:
            let data = try container.decode(EventUserData.self, forKey: .user)
            self = .user(data)
        case .system:
            let data = try container.decode(EventSystemData.self, forKey: .system)
            self = .system(data)
        case .error:
            let data = try container.decode(EventErrorData.self, forKey: .error)
            self = .error(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .user(let data):
            try container.encode(data, forKey: .user)
        case .system(let data):
            try container.encode(data, forKey: .system)
        case .error(let data):
            try container.encode(data, forKey: .error)
        }
    }
}


/// String enum (will be converted to Swift String enum with Codable)
public enum JobStatus: Codable {
    case queued
    case running
    case paused
    case completed
    case failed
    case cancelled
}

public struct LineStyle: Codable {
    public let dashPattern: [Double]?
    public let capStyle: String
    public let joinStyle: String

    private enum CodingKeys: String, CodingKey {
        case dashPattern = "dash_pattern"
        case capStyle = "cap_style"
        case joinStyle = "join_style"
    }
}

/// Mixed enum with both string-like and data variants
public enum MixedEnum {
    case simple(String)
    case withFields(MixedEnumWithFieldsData)
    case empty
}
public struct MixedEnumWithFieldsData: Codable {
    public let id: UInt32
    public let name: String
    public let metadata: [(String, String)]?
}

// MARK: - MixedEnum Codable Implementation
extension MixedEnum: Codable {
    private enum CodingKeys: String, CodingKey {
        case simple = "Simple"
        case withFields = "WithFields"
        case empty = "Empty"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .simple:
            // TODO: Implement tuple variant decoding for simple
            fatalError("Tuple variant decoding not implemented")
        case .withFields:
            let data = try container.decode(MixedEnumWithFieldsData.self, forKey: .withFields)
            self = .withFields(data)
        case .empty:
            self = .empty
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .simple:
            // TODO: Implement tuple variant encoding for simple
            fatalError("Tuple variant encoding not implemented")
        case .withFields(let data):
            try container.encode(data, forKey: .withFields)
        case .empty:
            try container.encodeNil(forKey: .empty)
        }
    }
}


/// Supporting structs for the Shape enum
public struct Point: Codable {
    public let x: Double
    public let y: Double
}

public struct Rectangle: Codable {
    public let topLeft: Point
    public let bottomRight: Point

    private enum CodingKeys: String, CodingKey {
        case topLeft = "top_left"
        case bottomRight = "bottom_right"
    }
}

/// Enum demonstrating different field patterns
public enum Shape {
    case none
    case point(Double, Double)
    case circle(ShapeCircleData)
    case rectangle(Rectangle)
    case line(ShapeLineData)
    case complex(ShapeComplexData)
}
public struct ShapeCircleData: Codable {
    public let center: Point
    public let radius: Double
}

public struct ShapeLineData: Codable {
    public let start: Point
    public let end: Point
    public let style: LineStyle
}

public struct ShapeComplexData: Codable {
    public let vertices: [Point]
    public let fillColor: Color
    public let strokeColor: Color?
    public let strokeWidth: Double
    public let isClosed: Bool

    private enum CodingKeys: String, CodingKey {
        case vertices = "vertices"
        case fillColor = "fill_color"
        case strokeColor = "stroke_color"
        case strokeWidth = "stroke_width"
        case isClosed = "is_closed"
    }
}

// MARK: - Shape Codable Implementation
extension Shape: Codable {
    private enum CodingKeys: String, CodingKey {
        case none = "None"
        case point = "Point"
        case circle = "Circle"
        case rectangle = "Rectangle"
        case line = "Line"
        case complex = "Complex"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .none:
            self = .none
        case .point:
            // TODO: Implement tuple variant decoding for point
            fatalError("Tuple variant decoding not implemented")
        case .circle:
            let data = try container.decode(ShapeCircleData.self, forKey: .circle)
            self = .circle(data)
        case .rectangle:
            // TODO: Implement tuple variant decoding for rectangle
            fatalError("Tuple variant decoding not implemented")
        case .line:
            let data = try container.decode(ShapeLineData.self, forKey: .line)
            self = .line(data)
        case .complex:
            let data = try container.decode(ShapeComplexData.self, forKey: .complex)
            self = .complex(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .none:
            try container.encodeNil(forKey: .none)
        case .point:
            // TODO: Implement tuple variant encoding for point
            fatalError("Tuple variant encoding not implemented")
        case .circle(let data):
            try container.encode(data, forKey: .circle)
        case .rectangle:
            // TODO: Implement tuple variant encoding for rectangle
            fatalError("Tuple variant encoding not implemented")
        case .line(let data):
            try container.encode(data, forKey: .line)
        case .complex(let data):
            try container.encode(data, forKey: .complex)
        }
    }
}


/// Enum with recursive references
public enum Tree<T> {
    case leaf(T)
    case branch(TreeBranchData)
}
public struct TreeBranchData: Codable {
    public let left: Tree<T>
    public let right: Tree<T>
    public let value: T
}

// MARK: - Tree Codable Implementation
extension Tree: Codable {
    private enum CodingKeys: String, CodingKey {
        case leaf = "Leaf"
        case branch = "Branch"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .leaf:
            // TODO: Implement tuple variant decoding for leaf
            fatalError("Tuple variant decoding not implemented")
        case .branch:
            let data = try container.decode(TreeBranchData.self, forKey: .branch)
            self = .branch(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .leaf:
            // TODO: Implement tuple variant encoding for leaf
            fatalError("Tuple variant encoding not implemented")
        case .branch(let data):
            try container.encode(data, forKey: .branch)
        }
    }
}


