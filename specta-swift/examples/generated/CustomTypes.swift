// Generated by MyApp - Custom Header
import Foundation

public enum api_result<T> {
    case success(api_resultSuccessData)
    case error(api_resultErrorData)
    case loading(api_resultLoadingData)
}
public struct api_resultSuccessData: Codable {
    public let data: T
    public let status: UInt16
}

public struct api_resultErrorData: Codable {
    public let message: String
    public let code: UInt32
}

public struct api_resultLoadingData: Codable {
    public let progress: Float
}

// MARK: - api_result Codable Implementation
extension api_result: Codable {
    private enum CodingKeys: String, CodingKey {
        case success = "Success"
        case error = "Error"
        case loading = "Loading"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .success:
            let data = try container.decode(api_resultSuccessData.self, forKey: .success)
            self = .success(data)
        case .error:
            let data = try container.decode(api_resultErrorData.self, forKey: .error)
            self = .error(data)
        case .loading:
            let data = try container.decode(api_resultLoadingData.self, forKey: .loading)
            self = .loading(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .success(let data):
            try container.encode(data, forKey: .success)
        case .error(let data):
            try container.encode(data, forKey: .error)
        case .loading(let data):
            try container.encode(data, forKey: .loading)
        }
    }
}


public struct user: Codable {
    public let id: UInt32
    public let name: String
    public let email: Optional<String>
    public let role: user_role
}

public enum user_role {
    case guest
    case user(user_roleUserData)
    case admin(user_roleAdminData)
    case super_admin(user_roleSuperAdminData)
}
public struct user_roleUserData: Codable {
    public let permissions: [String]
}

public struct user_roleAdminData: Codable {
    public let level: UInt8
    public let department: String
}

public struct user_roleSuperAdminData: Codable {
    public let access_level: UInt32
}

// MARK: - user_role Codable Implementation
extension user_role: Codable {
    private enum CodingKeys: String, CodingKey {
        case guest = "Guest"
        case user = "User"
        case admin = "Admin"
        case super_admin = "SuperAdmin"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .guest:
            self = .guest
        case .user:
            let data = try container.decode(user_roleUserData.self, forKey: .user)
            self = .user(data)
        case .admin:
            let data = try container.decode(user_roleAdminData.self, forKey: .admin)
            self = .admin(data)
        case .super_admin:
            let data = try container.decode(user_roleSuperAdminData.self, forKey: .super_admin)
            self = .super_admin(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .guest:
            try container.encodeNil(forKey: .guest)
        case .user(let data):
            try container.encode(data, forKey: .user)
        case .admin(let data):
            try container.encode(data, forKey: .admin)
        case .super_admin(let data):
            try container.encode(data, forKey: .super_admin)
        }
    }
}


