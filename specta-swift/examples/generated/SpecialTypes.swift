// This file has been generated by Specta. DO NOT EDIT.
import Foundation

// MARK: - Duration Helper
/// Helper struct to decode Rust Duration format {"secs": u64, "nanos": u32}
public struct RustDuration: Codable {
    public let secs: UInt64
    public let nanos: UInt32
    
    public var timeInterval: TimeInterval {
        return Double(secs) + Double(nanos) / 1_000_000_000.0
    }
}

// MARK: - Generated Types

/// API response with timing information
public struct ApiResponse: Codable {
    public let data: String
    public let processingDuration: RustDuration
    public let cacheDuration: RustDuration?
    public let transferDuration: RustDuration
    public let statusCode: UInt16

    private enum CodingKeys: String, CodingKey {
        case data = "data"
        case processingDuration = "processing_duration"
        case cacheDuration = "cache_duration"
        case transferDuration = "transfer_duration"
        case statusCode = "status_code"
    }
}

/// Struct with various timestamp types
public struct EventLog: Codable {
    public let eventId: String
    public let timestamp: String
    public let duration: RustDuration
    public let metadata: [(String, String)]?

    private enum CodingKeys: String, CodingKey {
        case eventId = "event_id"
        case timestamp = "timestamp"
        case duration = "duration"
        case metadata = "metadata"
    }
}

/// Example showcasing special type handling in specta-swift
/// 
/// This example demonstrates how specta-swift handles special Rust types
/// like Duration, UUID, chrono types, and other commonly used types
/// that need special conversion to Swift equivalents.
/// Struct with Duration fields (will be converted to RustDuration helper)
public struct IndexerMetrics: Codable {
    public let totalDuration: RustDuration
    public let discoveryDuration: RustDuration
    public let processingDuration: RustDuration
    public let contentDuration: RustDuration
    public let filesProcessed: UInt32
    public let avgTimePerFile: RustDuration

    private enum CodingKeys: String, CodingKey {
        case totalDuration = "total_duration"
        case discoveryDuration = "discovery_duration"
        case processingDuration = "processing_duration"
        case contentDuration = "content_duration"
        case filesProcessed = "files_processed"
        case avgTimePerFile = "avg_time_per_file"
    }
}

/// Job status with timing
public enum JobStatus {
    case queued
    case running(JobStatusRunningData)
    case completed(JobStatusCompletedData)
    case failed(JobStatusFailedData)
}
public struct JobStatusRunningData: Codable {
    public let startedAt: String
    public let elapsedTime: RustDuration
    public let estimatedCompletion: String?

    private enum CodingKeys: String, CodingKey {
        case startedAt = "started_at"
        case elapsedTime = "elapsed_time"
        case estimatedCompletion = "estimated_completion"
    }
}

public struct JobStatusCompletedData: Codable {
    public let startedAt: String
    public let completedAt: String
    public let totalDuration: RustDuration
    public let result: String

    private enum CodingKeys: String, CodingKey {
        case startedAt = "started_at"
        case completedAt = "completed_at"
        case totalDuration = "total_duration"
        case result = "result"
    }
}

public struct JobStatusFailedData: Codable {
    public let startedAt: String
    public let failedAt: String
    public let duration: RustDuration
    public let errorMessage: String

    private enum CodingKeys: String, CodingKey {
        case startedAt = "started_at"
        case failedAt = "failed_at"
        case duration = "duration"
        case errorMessage = "error_message"
    }
}

// MARK: - JobStatus Codable Implementation
extension JobStatus: Codable {
    private enum CodingKeys: String, CodingKey {
        case queued = "Queued"
        case running = "Running"
        case completed = "Completed"
        case failed = "Failed"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .queued:
            self = .queued
        case .running:
            let data = try container.decode(JobStatusRunningData.self, forKey: .running)
            self = .running(data)
        case .completed:
            let data = try container.decode(JobStatusCompletedData.self, forKey: .completed)
            self = .completed(data)
        case .failed:
            let data = try container.decode(JobStatusFailedData.self, forKey: .failed)
            self = .failed(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .queued:
            try container.encodeNil(forKey: .queued)
        case .running(let data):
            try container.encode(data, forKey: .running)
        case .completed(let data):
            try container.encode(data, forKey: .completed)
        case .failed(let data):
            try container.encode(data, forKey: .failed)
        }
    }
}


/// Performance metrics struct
public struct PerformanceMetrics: Codable {
    public let responseTime: RustDuration
    public let processingTime: RustDuration
    public let queryTime: RustDuration
    public let networkLatency: RustDuration
    public let totalTime: RustDuration

    private enum CodingKeys: String, CodingKey {
        case responseTime = "response_time"
        case processingTime = "processing_time"
        case queryTime = "query_time"
        case networkLatency = "network_latency"
        case totalTime = "total_time"
    }
}

/// Complex struct mixing Duration with other types
public struct SystemHealth: Codable {
    public let uptime: RustDuration
    public let lastCheck: RustDuration
    public let avgResponseTime: RustDuration
    public let status: String
    public let memoryUsage: Double
    public let cpuUsage: Double

    private enum CodingKeys: String, CodingKey {
        case uptime = "uptime"
        case lastCheck = "last_check"
        case avgResponseTime = "avg_response_time"
        case status = "status"
        case memoryUsage = "memory_usage"
        case cpuUsage = "cpu_usage"
    }
}

/// Configuration struct with timing information
public struct TaskConfig: Codable {
    public let name: String
    public let timeout: RustDuration
    public let retryInterval: RustDuration
    public let backoffDuration: RustDuration
    public let enabled: Bool

    private enum CodingKeys: String, CodingKey {
        case name = "name"
        case timeout = "timeout"
        case retryInterval = "retry_interval"
        case backoffDuration = "backoff_duration"
        case enabled = "enabled"
    }
}

