// This file has been generated by Specta. DO NOT EDIT.
import Foundation

/// Generic struct demonstrating type parameters
public struct ApiResponse<T, E>: Codable {
    public let data: T?
    public let error: E?
    public let statusCode: UInt16
    public let headers: [(String, String)]

    private enum CodingKeys: String, CodingKey {
        case data = "data"
        case error = "error"
        case statusCode = "status_code"
        case headers = "headers"
    }
}

/// Comprehensive example showcasing basic Rust types and their Swift equivalents
/// 
/// This example demonstrates how specta-swift handles fundamental Rust types
/// and converts them to appropriate Swift types.
/// Basic primitive types
public struct Primitives: Codable {
    public let smallInt: Int8
    public let unsignedSmall: UInt8
    public let shortInt: Int16
    public let unsignedShort: UInt16
    public let regularInt: Int32
    public let unsignedInt: UInt32
    public let longInt: Int64
    public let unsignedLong: UInt64
    public let singlePrecision: Float
    public let doublePrecision: Double
    public let isActive: Bool
    public let singleChar: Character
    public let name: String
    public let optionalName: String?
    public let tags: [String]
    public let scores: [Double]
    public let userIds: [UInt32]
    public let matrix: [[Double]]
    public let stringPairs: [(String, String)]

    private enum CodingKeys: String, CodingKey {
        case smallInt = "small_int"
        case unsignedSmall = "unsigned_small"
        case shortInt = "short_int"
        case unsignedShort = "unsigned_short"
        case regularInt = "regular_int"
        case unsignedInt = "unsigned_int"
        case longInt = "long_int"
        case unsignedLong = "unsigned_long"
        case singlePrecision = "single_precision"
        case doublePrecision = "double_precision"
        case isActive = "is_active"
        case singleChar = "single_char"
        case name = "name"
        case optionalName = "optional_name"
        case tags = "tags"
        case scores = "scores"
        case userIds = "user_ids"
        case matrix = "matrix"
        case stringPairs = "string_pairs"
    }
}

/// Enum with different variant types
public enum Status {
    case active
    case pending(String)
    case error(String, UInt32)
    case loading(StatusLoadingData)
}
public struct StatusLoadingData: Codable {
    public let progress: Float
    public let message: String?
}

// MARK: - Status Codable Implementation
extension Status: Codable {
    private enum CodingKeys: String, CodingKey {
        case active = "Active"
        case pending = "Pending"
        case error = "Error"
        case loading = "Loading"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .active:
            self = .active
        case .pending:
            // TODO: Implement tuple variant decoding for pending
            fatalError("Tuple variant decoding not implemented")
        case .error:
            // TODO: Implement tuple variant decoding for error
            fatalError("Tuple variant decoding not implemented")
        case .loading:
            let data = try container.decode(StatusLoadingData.self, forKey: .loading)
            self = .loading(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .active:
            try container.encodeNil(forKey: .active)
        case .pending:
            // TODO: Implement tuple variant encoding for pending
            fatalError("Tuple variant encoding not implemented")
        case .error:
            // TODO: Implement tuple variant encoding for error
            fatalError("Tuple variant encoding not implemented")
        case .loading(let data):
            try container.encode(data, forKey: .loading)
        }
    }
}


/// Nested struct demonstrating complex relationships
public struct User: Codable {
    public let id: UInt32
    public let username: String
    public let email: String
    public let profile: UserProfile
    public let preferences: UserPreferences
    public let status: Status
    public let metadata: UserMetadata?
}

public struct UserMetadata: Codable {
    public let createdAt: String
    public let lastLogin: String?
    public let loginCount: UInt32
    public let isVerified: Bool

    private enum CodingKeys: String, CodingKey {
        case createdAt = "created_at"
        case lastLogin = "last_login"
        case loginCount = "login_count"
        case isVerified = "is_verified"
    }
}

public struct UserPreferences: Codable {
    public let theme: String
    public let language: String
    public let notificationsEnabled: Bool
    public let privacyLevel: UInt8

    private enum CodingKeys: String, CodingKey {
        case theme = "theme"
        case language = "language"
        case notificationsEnabled = "notifications_enabled"
        case privacyLevel = "privacy_level"
    }
}

public struct UserProfile: Codable {
    public let firstName: String
    public let lastName: String
    public let bio: String?
    public let avatarUrl: String?
    public let birthDate: String?

    private enum CodingKeys: String, CodingKey {
        case firstName = "first_name"
        case lastName = "last_name"
        case bio = "bio"
        case avatarUrl = "avatar_url"
        case birthDate = "birth_date"
    }
}

