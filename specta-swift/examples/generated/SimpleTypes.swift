// This file has been generated by Specta. DO NOT EDIT.
import Foundation

public enum ApiResult<T> {
    case success(ApiResultSuccessData)
    case error(ApiResultErrorData)
    case loading(ApiResultLoadingData)
}
public struct ApiResultSuccessData: Codable {
    public let data: T
    public let status: UInt16
}

public struct ApiResultErrorData: Codable {
    public let message: String
    public let code: UInt32
}

public struct ApiResultLoadingData: Codable {
    public let progress: Float
}

// MARK: - ApiResult Codable Implementation
extension ApiResult: Codable {
    private enum CodingKeys: String, CodingKey {
        case success = "Success"
        case error = "Error"
        case loading = "Loading"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .success:
            let data = try container.decode(ApiResultSuccessData.self, forKey: .success)
            self = .success(data)
        case .error:
            let data = try container.decode(ApiResultErrorData.self, forKey: .error)
            self = .error(data)
        case .loading:
            let data = try container.decode(ApiResultLoadingData.self, forKey: .loading)
            self = .loading(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .success(let data):
            try container.encode(data, forKey: .success)
        case .error(let data):
            try container.encode(data, forKey: .error)
        case .loading(let data):
            try container.encode(data, forKey: .loading)
        }
    }
}


public struct User: Codable {
    public let id: UInt32
    public let name: String
    public let email: String?
    public let role: UserRole
}

public enum UserRole {
    case guest
    case user(UserRoleUserData)
    case admin(UserRoleAdminData)
    case superAdmin(UserRoleSuperAdminData)
}
public struct UserRoleUserData: Codable {
    public let permissions: [String]
}

public struct UserRoleAdminData: Codable {
    public let level: UInt8
    public let department: String
}

public struct UserRoleSuperAdminData: Codable {
    public let accessLevel: UInt32

    private enum CodingKeys: String, CodingKey {
        case accessLevel = "access_level"
    }
}

// MARK: - UserRole Codable Implementation
extension UserRole: Codable {
    private enum CodingKeys: String, CodingKey {
        case guest = "Guest"
        case user = "User"
        case admin = "Admin"
        case superAdmin = "SuperAdmin"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .guest:
            self = .guest
        case .user:
            let data = try container.decode(UserRoleUserData.self, forKey: .user)
            self = .user(data)
        case .admin:
            let data = try container.decode(UserRoleAdminData.self, forKey: .admin)
            self = .admin(data)
        case .superAdmin:
            let data = try container.decode(UserRoleSuperAdminData.self, forKey: .superAdmin)
            self = .superAdmin(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .guest:
            try container.encodeNil(forKey: .guest)
        case .user(let data):
            try container.encode(data, forKey: .user)
        case .admin(let data):
            try container.encode(data, forKey: .admin)
        case .superAdmin(let data):
            try container.encode(data, forKey: .superAdmin)
        }
    }
}


