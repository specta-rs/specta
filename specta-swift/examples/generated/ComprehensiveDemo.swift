// This file has been generated by Specta. DO NOT EDIT.
import Foundation

// MARK: - Duration Helper
/// Helper struct to decode Rust Duration format {"secs": u64, "nanos": u32}
public struct RustDuration: Codable {
    public let secs: UInt64
    public let nanos: UInt32
    
    public var timeInterval: TimeInterval {
        return Double(secs) + Double(nanos) / 1_000_000_000.0
    }
}

// MARK: - Generated Types

/// Admin level enum
public enum AdminLevel: Codable {
    case junior
    case senior
    case lead
    case director
}

/// API response wrapper
public struct ApiResponse<T, E>: Codable {
    public let data: T?
    public let error: E?
    public let status: ResponseStatus
    public let metadata: ResponseMetadata
}

/// File attachment
public struct Attachment: Codable {
    public let id: String
    public let filename: String
    public let size: UInt64
    public let mimeType: String
    public let uploadedAt: String
    public let uploadedBy: UInt32

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case filename = "filename"
        case size = "size"
        case mimeType = "mime_type"
        case uploadedAt = "uploaded_at"
        case uploadedBy = "uploaded_by"
    }
}

/// Data sharing settings
public struct DataSharing: Codable {
    public let analytics: Bool
    public let marketing: Bool
    public let thirdParty: Bool
    public let research: Bool

    private enum CodingKeys: String, CodingKey {
        case analytics = "analytics"
        case marketing = "marketing"
        case thirdParty = "third_party"
        case research = "research"
    }
}

/// Display settings
public struct DisplaySettings: Codable {
    public let itemsPerPage: UInt32
    public let dateFormat: String
    public let timeFormat: String
    public let currency: String
    public let compactMode: Bool

    private enum CodingKeys: String, CodingKey {
        case itemsPerPage = "items_per_page"
        case dateFormat = "date_format"
        case timeFormat = "time_format"
        case currency = "currency"
        case compactMode = "compact_mode"
    }
}

/// Health status enum
public enum HealthStatus: Codable {
    case healthy
    case degraded
    case unhealthy
    case unknown
}

/// Notification frequency enum
public enum NotificationFrequency: Codable {
    case immediate
    case hourly
    case daily
    case weekly
    case never
}

/// Notification settings
public struct NotificationSettings: Codable {
    public let emailEnabled: Bool
    public let pushEnabled: Bool
    public let smsEnabled: Bool
    public let desktopEnabled: Bool
    public let frequency: NotificationFrequency

    private enum CodingKeys: String, CodingKey {
        case emailEnabled = "email_enabled"
        case pushEnabled = "push_enabled"
        case smsEnabled = "sms_enabled"
        case desktopEnabled = "desktop_enabled"
        case frequency = "frequency"
    }
}

/// Pagination information
public struct PaginationInfo: Codable {
    public let page: UInt32
    public let perPage: UInt32
    public let totalPages: UInt32
    public let totalItems: UInt64
    public let hasNext: Bool
    public let hasPrev: Bool

    private enum CodingKeys: String, CodingKey {
        case page = "page"
        case perPage = "per_page"
        case totalPages = "total_pages"
        case totalItems = "total_items"
        case hasNext = "has_next"
        case hasPrev = "has_prev"
    }
}

/// Priority enum (string enum)
public enum Priority: Codable {
    case low
    case medium
    case high
    case critical
    case emergency
}

/// Privacy settings
public struct PrivacySettings: Codable {
    public let profileVisibility: Visibility
    public let activityVisibility: Visibility
    public let dataSharing: DataSharing

    private enum CodingKeys: String, CodingKey {
        case profileVisibility = "profile_visibility"
        case activityVisibility = "activity_visibility"
        case dataSharing = "data_sharing"
    }
}

/// Response metadata
public struct ResponseMetadata: Codable {
    public let requestId: String
    public let timestamp: String
    public let processingTime: RustDuration
    public let version: String
    public let pagination: PaginationInfo?

    private enum CodingKeys: String, CodingKey {
        case requestId = "request_id"
        case timestamp = "timestamp"
        case processingTime = "processing_time"
        case version = "version"
        case pagination = "pagination"
    }
}

/// Response status enum
public enum ResponseStatus: Codable {
    case success
    case partialSuccess
    case error
    case validationError
    case authenticationError
    case authorizationError
    case notFound
    case rateLimited
}

/// Review comment
public struct ReviewComment: Codable {
    public let id: UInt32
    public let author: UInt32
    public let content: String
    public let createdAt: String
    public let updatedAt: String
    public let isResolved: Bool
    public let parentComment: UInt32?
    public let attachments: [Attachment]

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case author = "author"
        case content = "content"
        case createdAt = "created_at"
        case updatedAt = "updated_at"
        case isResolved = "is_resolved"
        case parentComment = "parent_comment"
        case attachments = "attachments"
    }
}

/// Service status
public struct ServiceStatus: Codable {
    public let name: String
    public let status: HealthStatus
    public let responseTime: RustDuration
    public let lastCheck: String
    public let errorCount: UInt32

    private enum CodingKeys: String, CodingKey {
        case name = "name"
        case status = "status"
        case responseTime = "response_time"
        case lastCheck = "last_check"
        case errorCount = "error_count"
    }
}

/// Subtask with timing information
public struct SubTask: Codable {
    public let id: UInt32
    public let title: String
    public let description: String?
    public let status: SubTaskStatus
    public let estimatedDuration: RustDuration
    public let actualDuration: RustDuration?
    public let assignee: UInt32?
    public let createdAt: String
    public let completedAt: String?

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case title = "title"
        case description = "description"
        case status = "status"
        case estimatedDuration = "estimated_duration"
        case actualDuration = "actual_duration"
        case assignee = "assignee"
        case createdAt = "created_at"
        case completedAt = "completed_at"
    }
}

/// Subtask status (simple enum)
public enum SubTaskStatus: Codable {
    case pending
    case inProgress
    case completed
    case skipped
}

/// System health information
public struct SystemHealth: Codable {
    public let status: HealthStatus
    public let uptime: RustDuration
    public let lastCheck: String
    public let services: [ServiceStatus]
    public let metrics: SystemMetrics

    private enum CodingKeys: String, CodingKey {
        case status = "status"
        case uptime = "uptime"
        case lastCheck = "last_check"
        case services = "services"
        case metrics = "metrics"
    }
}

/// System metrics
public struct SystemMetrics: Codable {
    public let cpuUsage: Double
    public let memoryUsage: Double
    public let diskUsage: Double
    public let networkUsage: Double
    public let activeUsers: UInt32
    public let totalRequests: UInt64
    public let errorRate: Double

    private enum CodingKeys: String, CodingKey {
        case cpuUsage = "cpu_usage"
        case memoryUsage = "memory_usage"
        case diskUsage = "disk_usage"
        case networkUsage = "network_usage"
        case activeUsers = "active_users"
        case totalRequests = "total_requests"
        case errorRate = "error_rate"
    }
}

/// Comprehensive demonstration of ALL specta-swift functionality
/// 
/// This example showcases every feature and capability of specta-swift in a single,
/// realistic application scenario. It demonstrates complex type relationships,
/// various enum patterns, special types, and advanced features.
/// Main application types for a task management system
public struct Task: Codable {
    public let id: UInt32
    public let title: String
    public let description: String?
    public let status: TaskStatus
    public let priority: Priority
    public let assignee: User?
    public let createdAt: String
    public let updatedAt: String
    public let dueDate: String?
    public let duration: RustDuration?
    public let tags: [String]
    public let metadata: TaskMetadata
    public let subtasks: [SubTask]

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case title = "title"
        case description = "description"
        case status = "status"
        case priority = "priority"
        case assignee = "assignee"
        case createdAt = "created_at"
        case updatedAt = "updated_at"
        case dueDate = "due_date"
        case duration = "duration"
        case tags = "tags"
        case metadata = "metadata"
        case subtasks = "subtasks"
    }
}

/// Task metadata
public struct TaskMetadata: Codable {
    public let createdBy: UInt32
    public let lastModifiedBy: UInt32
    public let version: UInt32
    public let customFields: [(String, String)]
    public let attachments: [Attachment]
    public let watchers: [UInt32]
    public let dependencies: [UInt32]

    private enum CodingKeys: String, CodingKey {
        case createdBy = "created_by"
        case lastModifiedBy = "last_modified_by"
        case version = "version"
        case customFields = "custom_fields"
        case attachments = "attachments"
        case watchers = "watchers"
        case dependencies = "dependencies"
    }
}

/// Task status enum with mixed variants
public enum TaskStatus {
    case todo
    case inProgress(TaskStatusInProgressData)
    case blocked(TaskStatusBlockedData)
    case review(TaskStatusReviewData)
    case completed(TaskStatusCompletedData)
    case cancelled(TaskStatusCancelledData)
}
public struct TaskStatusInProgressData: Codable {
    public let startedAt: String
    public let estimatedCompletion: String?
    public let progress: Float

    private enum CodingKeys: String, CodingKey {
        case startedAt = "started_at"
        case estimatedCompletion = "estimated_completion"
        case progress = "progress"
    }
}

public struct TaskStatusBlockedData: Codable {
    public let reason: String
    public let blockedBy: [UInt32]
    public let estimatedUnblock: String?

    private enum CodingKeys: String, CodingKey {
        case reason = "reason"
        case blockedBy = "blocked_by"
        case estimatedUnblock = "estimated_unblock"
    }
}

public struct TaskStatusReviewData: Codable {
    public let reviewer: String
    public let reviewStartedAt: String
    public let comments: [ReviewComment]

    private enum CodingKeys: String, CodingKey {
        case reviewer = "reviewer"
        case reviewStartedAt = "review_started_at"
        case comments = "comments"
    }
}

public struct TaskStatusCompletedData: Codable {
    public let completedAt: String
    public let completionTime: RustDuration
    public let finalNotes: String?

    private enum CodingKeys: String, CodingKey {
        case completedAt = "completed_at"
        case completionTime = "completion_time"
        case finalNotes = "final_notes"
    }
}

public struct TaskStatusCancelledData: Codable {
    public let reason: String
    public let cancelledAt: String

    private enum CodingKeys: String, CodingKey {
        case reason = "reason"
        case cancelledAt = "cancelled_at"
    }
}

// MARK: - TaskStatus Codable Implementation
extension TaskStatus: Codable {
    private enum CodingKeys: String, CodingKey {
        case todo = "Todo"
        case inProgress = "InProgress"
        case blocked = "Blocked"
        case review = "Review"
        case completed = "Completed"
        case cancelled = "Cancelled"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .todo:
            self = .todo
        case .inProgress:
            let data = try container.decode(TaskStatusInProgressData.self, forKey: .inProgress)
            self = .inProgress(data)
        case .blocked:
            let data = try container.decode(TaskStatusBlockedData.self, forKey: .blocked)
            self = .blocked(data)
        case .review:
            let data = try container.decode(TaskStatusReviewData.self, forKey: .review)
            self = .review(data)
        case .completed:
            let data = try container.decode(TaskStatusCompletedData.self, forKey: .completed)
            self = .completed(data)
        case .cancelled:
            let data = try container.decode(TaskStatusCancelledData.self, forKey: .cancelled)
            self = .cancelled(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .todo:
            try container.encodeNil(forKey: .todo)
        case .inProgress(let data):
            try container.encode(data, forKey: .inProgress)
        case .blocked(let data):
            try container.encode(data, forKey: .blocked)
        case .review(let data):
            try container.encode(data, forKey: .review)
        case .completed(let data):
            try container.encode(data, forKey: .completed)
        case .cancelled(let data):
            try container.encode(data, forKey: .cancelled)
        }
    }
}


/// Theme enum (string enum)
public enum Theme: Codable {
    case light
    case dark
    case auto
    case custom
}

/// User information
public struct User: Codable {
    public let id: UInt32
    public let username: String
    public let email: String
    public let profile: UserProfile
    public let preferences: UserPreferences
    public let role: UserRole
    public let isActive: Bool
    public let lastLogin: String?
    public let createdAt: String

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case username = "username"
        case email = "email"
        case profile = "profile"
        case preferences = "preferences"
        case role = "role"
        case isActive = "is_active"
        case lastLogin = "last_login"
        case createdAt = "created_at"
    }
}

/// User preferences
public struct UserPreferences: Codable {
    public let theme: Theme
    public let notifications: NotificationSettings
    public let privacy: PrivacySettings
    public let display: DisplaySettings
}

/// User profile with nested data
public struct UserProfile: Codable {
    public let firstName: String
    public let lastName: String
    public let bio: String?
    public let avatarUrl: String?
    public let timezone: String
    public let language: String

    private enum CodingKeys: String, CodingKey {
        case firstName = "first_name"
        case lastName = "last_name"
        case bio = "bio"
        case avatarUrl = "avatar_url"
        case timezone = "timezone"
        case language = "language"
    }
}

/// User role with permissions
public enum UserRole {
    case user
    case moderator(UserRoleModeratorData)
    case admin(UserRoleAdminData)
    case superAdmin(UserRoleSuperAdminData)
}
public struct UserRoleModeratorData: Codable {
    public let permissions: [String]
    public let department: String
}

public struct UserRoleAdminData: Codable {
    public let level: AdminLevel
    public let departments: [String]
    public let specialAccess: [String]

    private enum CodingKeys: String, CodingKey {
        case level = "level"
        case departments = "departments"
        case specialAccess = "special_access"
    }
}

public struct UserRoleSuperAdminData: Codable {
    public let systemAccess: Bool
    public let auditLogs: Bool

    private enum CodingKeys: String, CodingKey {
        case systemAccess = "system_access"
        case auditLogs = "audit_logs"
    }
}

// MARK: - UserRole Codable Implementation
extension UserRole: Codable {
    private enum CodingKeys: String, CodingKey {
        case user = "User"
        case moderator = "Moderator"
        case admin = "Admin"
        case superAdmin = "SuperAdmin"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .user:
            self = .user
        case .moderator:
            let data = try container.decode(UserRoleModeratorData.self, forKey: .moderator)
            self = .moderator(data)
        case .admin:
            let data = try container.decode(UserRoleAdminData.self, forKey: .admin)
            self = .admin(data)
        case .superAdmin:
            let data = try container.decode(UserRoleSuperAdminData.self, forKey: .superAdmin)
            self = .superAdmin(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .user:
            try container.encodeNil(forKey: .user)
        case .moderator(let data):
            try container.encode(data, forKey: .moderator)
        case .admin(let data):
            try container.encode(data, forKey: .admin)
        case .superAdmin(let data):
            try container.encode(data, forKey: .superAdmin)
        }
    }
}


/// Visibility enum
public enum Visibility: Codable {
    case public
    case friends
    case private
    case hidden
}

